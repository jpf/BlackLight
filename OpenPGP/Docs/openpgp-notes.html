<!-- openpgp-notes.html -->
<html>
<head>
<title> OpenPGP notes </title>
</head>
<body bgcolor="#000000" text="#00ff00">
<h1> OpenPGP notes </h1>

This document is a set of notes for RFC-4880 ("OpenPGP Message Format").
These notes do not follow the outline of RFC-4880.
Instead, the notes start with the grammars for OpenPGP messages
and OpenPGP certificates, and then refine these down to the bit level.
<p>

<br>
<hr color="#00FF00">
<!----------------------------------------------------------------------------->
<h2> OpenPGP messages </h2>

OpenPGP messages are constructed from OpenPGP packets.
An <i>OpenPGP packet</i> is simply a block of bytes that follows a well-defined format.
Different types of OpenPGP packets contain different assortments of information.
An <i>OpenPGP message</i> is a sequence of one or more OpenPGP packets.
An OpenPGP message complies with the following grammatical rules.
<p>

<pre>
  openpgp-message :=
      literal-message
      compressed-message  |
      signed-message      |
      encrypted-message   |

  literal-message :=
      CB-packet

  compressed-message :=
      C8-packet

  signed-message :=
      C2-packet  openpgp-message  |
      C4-packet  openpgp-message  C2-packet

  encrypted-message :=
      esk-sequence  encrypted-data-packet  |
      encrypted-data-packet

  esk-sequence :=
      esk-sequence  esk-packet  |
      esk-packet

  esk-packet :=
      C1-packet  |
      C3-packet

  encrypted-data-packet :=
      C9-packet  |
      D2-packet
</pre>
In addition, the C8-packet, the C9-packet, and the D2-packet,
when decrypted, must encapsulate a valid openpgp-message.
This provides for the production of many different OpenPGP messages.

<h3> Example </h3>

Bob wishes to send Alice a signed and encrypted message.
Bob has already given Alice a copy of his public signature key.
And Alice has already given Bob a copy of her public encryption key.
<p>
Bob first creates a literal-message.
He writes his message into a text file
and then encapsulates this file in a CB-packet.
The grammar above states that a single CB-packet is a valid literal-message,
and that a literal-message is a valid openpgp-message.
<p>
Bob then creates a compressed-message.
He creates a C8-packet by compressing the literal-message
that he just constructed in the previous step.
The grammar states that a single C8-packet is a valid compressed-message,
and that a compressed-message is a valid openpgp-message.
<p>
Bob now creates a signed-message.
He computes a hash on the the compressed-message from the previous step.
He then uses his secret signature key to compute a signature of the hash.
Finally he constructs a signed-message consisting of three packets:
a C4-packet, the C8-packet, and a C2-packet.
The C2-packet contains the signature of the hash.
The grammar states that a C4-packet, followed by an openpgp-message,
followed by a C2-packet, is a valid signed-message,
and that a signed-message is a valid openpgp-message.
<p>
Finally, Bob creates an encrypted-message.
This consists of an esk-sequence and an encrypted-data-packet.
The esk-sequence is an esk-packet consisting of a single C1-packet.
The C1-packet contains a symmetric key that has been encrypted 
using Alice's public encryption key.
The symmetric key was randomly chosen by Bob.
The encrypted-data-packet is a single C9-packet.
The C9-packet contains blocks of data that were generated by a symmetric encryption algorithm.
The algorithm used the symmetric key that was randomly chosen by Bob.
The input to the algorithm was the signed-message from above
(the C2-packet, the C8-packet, and the C2-packet).
The grammar states that an esk-packet, follwed by an encrypted-data-packet,
is a valid encrypted-message, and that an encrypted-message is a valid openpgp-message.
Bob transmits this valid openpgp-message to Alice.
<p>
To summarize, Bob has constructed a valid openpgp-message by encapsulation.
No one will be able to read the plaintext message except Alice.
And she is assured that the message could only have been written by Bob.
<p>

<pre>
    openpgp-message
           |
           |
       C1-packet  C9-packet
                      |
                      |
                  C4-packet  C8-packet  C2-packet
                                 |
                                 |
                             CB-packet
</pre>
<p>

Alice takes Bob's openpgp-message and deconstructs it
all the way down to the original plaintext message.
The openpgp-message consists of the C1-packet and the C9-packet.
Alice uses the C1-packet to decrypt the C9-packet.
This produces the C4-packet, the C8-packet, and the C2-packet.
Alice computes the hash of the C8-packet and verifies the signature in the C2-packet.
Finally, she unzips the C8-packet to produce the CB-packet,
which contains the original plaintext message.
<p>


<br>
<hr color="#00FF00">
<!----------------------------------------------------------------------------->
<h2> OpenPGP certificates </h2>

<blockquote>
"OpenPGP provides key management and certificate services, 
but many of these are beyond the scope of this document...
An OpenPGP message, keyring, certificate, and so forth 
consists of a number of packets...
A public-key packet starts a series of packets that forms 
an OpenPGP key (sometimes called an OpenPGP certificate)...
[RFC-4880]
</blockquote>
<p>

Although RFC-4880 mentions the OpenPGP certificate, 
it fails to specify a format for one.
The grammar in section 11.3 cites neither the public key packet 
nor the user ID packet.
Therefore, given the need for an OpenPGP certificate specification,
these notes suggest the following grammar.
<p>

<pre>
  openpgp-certificate :=
      C4-packet  public-keyset  C2-packet

  public-keyset :=
      public-signature-key
      public-encryption-key
      owner-identity-string

  public-signature-key :=
      C6-packet

  public-encryption-key :=
      C6-packet

  owner-identity-string :=
      CD-packet
</pre>
<p>

The openpgp-certificate is similar to the signed-message
in the openpgp-message grammar.
The C4-packet and the C2-packet define the boundries
over which a hash will be computed.
The C4-packet facilitates a one-pass hash computation.
The C2-packet contains a signature of the hash value,
and it also provides algorithm preferences in its subpackets.
<p>

The public-signature-key is a C6-packet.
This key may be used to verify the signature of a hash
of a subsequent openpgp-message from the key's owner.
<p>

The public-encryption-key is also a C6-packet.
This key may used to encrypt a symmetric session key
that is employed by a symmetric algorithm to encrypt
a subsequent openpgp-message to the key's owner.
<p>

The owner-identity-string is a CD-packet.
It contains an UTF-8 string that identifies the owner of the two public keys.
The string is typically the email address of the owner.
<p>

<br>
<hr color="#00FF00">
<!----------------------------------------------------------------------------->
<h2> OpenPGP packets </h2>  

OpenPGP supports the following packet types.
The first column is the "tag" number.
The second column contains the abbreviated packet names that are referenced 
in the OpenPGP message and OpenPGP certificate grammars above.
The prefix of each packet name is the hexadecimal representation 
of the first byte in that packet using a new header format.
The third column contains the RFC-4880 packet names.
<pre>
  1   C1-packet   PUBLIC-KEY-ENCRYPTED-SESSION-KEY-PACKET
  2   C2-packet   SIGNATURE-PACKET
  3   C3-packet   SYMMETRIC-KEY-ENCRYPTED-SESSION-KEY-PACKET
  4   C4-packet   ONE-PASS-SIGNATURE-PACKET
  5   C5-packet   SECRET-KEY-PACKET
  6   C6-packet   PUBLIC-KEY-PACKET
  7   C7-packet   SECRET-SUBKEY-PACKET
  8   C8-packet   COMPRESSED-DATA-PACKET
  9   C9-packet   SYMMETRICALLY-ENCRYPTED-DATA-PACKET
  10  CA-packet   MARKER-PACKET
  11  CB-packet   LITERAL-DATA-PACKET
  12  CC-packet   TRUST-PACKET
  13  CD-packet   USER-ID-PACKET
  14  CE-packet   PUBLIC-SUBKEY-PACKET
  17  D1-packet   USER-ATTRIBUTE-PACKET
  18  D2-packet   SYM-ENCRYPTED-INTEGRITY-PROTECTED-DATA-PACKET
  19  D3-packet   MODIFICATION-DETECTION-CODE-PACKET
</pre>
<p>
<br>

There are two basic packets: a simple-packet and a compound-packet.
The simple-packet consists of a pkt-header followed by a pkt-body,
where the pkt-header is a few bytes long and the pkt-body is many bytes long.
<p>
The compound-packet consists of a pkt-headr followed by a partial-body,
followed by zero or more new-len-P and partial-body pairs,
and ending with either a new-len-1, a new-len-2, or a new-len-5,
followed by the last partial-body.
The compound-packet is typically used in cases where the length of the packet body
is not known a priori, such as a symmetrically encrypted data packet.
<pre>
  packet :=  simple-packet | compound-packet

  simple-packet :=  pkt-header pkt-body

  compound-packet :=  new-header-P partial-body 
                      [ new-len-P partial-body ]...
		      { new-len-1 | new-len-2 | new-len-5 } partial-body
</pre>


<h3> pkt-header </h3>

The pkt-header is comprised of a one-byte <i>tag</i> that identifies the packet type,
plus one or more bytes that specify the length of the pkt-body.
There are four old format packet headers and four new format packet headers.
PGP version 2.6.x uses the old format packet headers.
If interoperability is not an issue, the new format packet headers are recommended.
<pre>
  pkt-header := old-header-2 |

                old-header-3 |

                old-header-5 |

                old-header-I |

                new-header-2 |

                new-header-3 |

                new-header-6 |

                new-header-P
</pre>

<h3> old-header-2 </h3>
This is a two-octet header.
The first octet (old-tag-A) is an old format tag.
The second octet (old-len-1) is an old format length.
The old-tag-A octet has bit 7 set, bit 6 clear, bit 1 clear, and bit 0 clear.
The four bits in between specify the packet type, 0 to 15.
The old-len-1 octet specifies the number of bytes in the pkt-body, 0 to 255,
which is 0x00 to 0xFF.
<pre>
  old-header-2  :=  old-tag-A  old-len-1

  old-tag-A     :=  10xxxx00

  old-len-1     :=  XX

  XX            :=  {0x00,0x01,...,0xFF}
</pre>

<h3> old-header-3 </h3>
This is a three-octet header.
The first octet (old-tag-B) is an old format tag.
The second and third octets (old-len-2) are an old format length.
The old-tag-B octet has bit 7 set, bit 6 clear, bit 1 clear, and bit 0 set.
The four bits in between specify the packet type, 0 to 15.
The old-len-2 octets specify the number of bytes in the pkt-body, 0 to 65535,
which is 0x0000 to 0xFFFF.
<pre>
  old-header-3  :=  old-tag-B  old-len-2

  old-tag-B     :=  10xxxx01

  old-len-2     :=  XX XX
</pre>

<h3> old-header-5 </h3>
This is a five-octet header.
The first octet (old-tag-C) is an old format tag.
The second, third, fourth, and fifth octets (old-len-4) are an old format length.
The old-tag-C octet has bit 7 set, bit 6 clear, bit 1 set, and bit 0 clear.
The four bits in between specify the packet type, 0 to 15.
The old-len-4 octets specify the number of bytes in the pkt-body, 0 to 4294967295,
which is 0x00000000 to 0xFFFFFFFF.
<pre>
  old-header-5  :=  old-tag-C  old-len-4

  old-tag-C     :=  10xxxx10

  old-len-4     :=  XX XX XX XX
                   
</pre>

<h3> old-header-I </h3>
This is a one-octet header.
The one octet (old-tag-D) is an old format tag.
The old-tag-D octet has bit 7 set, bit 6 clear, bit 1 set, and bit 0 set.
The four bits in between specify the packet type, 0 to 15.
"The packet is of indeterminate length.
The implementation must determine how long the packet is.
If the packet is in a file, 
this means that the packet extends until the end of the file.
In general, an implementation should not use indeterminate-length packets 
except where the end of the data will be clear from the context, 
and even then it is better to use a definite length, or a new format header."
<pre>
  old-header-I  :=  old-tag-D

  old-tag-D     :=  10xxxx11
</pre>

<h3> new-header-2 </h3>
This is a two-octet header.
The first octet (new-tag) is a new format tag.
The second octet (new-len-1) is a new format length.
The new-tag octet has bits 7 and 6 set.
The other six bits in the tag specify the packet type, 0 to 63.
The new-len-1 octet specifies the number of bytes in the pkt-body, 0 to 191,
which is 0x00 to 0xBF.
<pre>
  new-header-2  :=  new-tag  new-len-1

  new-tag       :=  11xxxxxx

  new-len-1     :=  XX
</pre>


<h3> new-header-3 </h3>
This is a three-octet header.
The first octet (new-tag) is a new format tag.
The second and third octets (new-len-2) are a new format length.
The new-tag octet has bits 7 and 6 set.
The other six bits in the tag specify the packet type, 0 to 63.
The new-len-2 octets specify the number of bytes in the pkt-body, 192 to 8383.
The two-byte value represents the actual length of the body, plus 48960.
It is recognized because its first octet is in the range 192 to 223, 
which is 0xC0 to0xDF.
<pre>
  new-header-3  :=  new-tag  new-len-2

  new-tag       :=  11xxxxxx

  new-len-2     :=  110xxxxx  xxxxxxxx
</pre>

<h3> new-header-6 </h3>
This is a six-octet header.
The first octet (new-tag) is a new format tag.
The second octet is the constant 0xFF.
The last four octets (new-len-4) are a new format length.
The new-tag octet has bits 7 and 6 set.
The other six bits in the tag specify the packet type, 0 to 63.
The new-len-5 octets specify the number of bytes in the pkt-body, 0 to 4294967295,
which is 0x00000000 to 0xFFFFFFFF.
<pre>
  new-header-6  :=  new-tag  new-len-5

  new-tag       :=  11xxxxxx

  new-len-5     :=  FF XX XX XX XX
</pre>

<h3> new-header-P </h3>
This is a two-octet header.
The first octet (new-tag) is a new format tag.
The second octet (new-len-P) is a new format length, 
called a <i>Partial Body Length</i>.
The new-tag octet has bits 7 and 6 set.
The other six bits in the tag specify the packet type, 0 to 63.
The new-len-P octet has two fields.
The first field is the three most significant bits, each of which is set.
The second field is the five least significant bits.
The second field specifies the log base 2 of the number of bytes 
in the pkt-body, i.e. an integer in {0,1,2,3,...,30}. 
A log of 31 is not allowed, as it would conflict 
with the second byte (0xFF) in new-header-6.
"A Partial Body Length ... is one octet long and encodes the length
of only part of the data packet.  This length is a power of 2, from 1
to 1,073,741,824 (2 to the 30th power).  It is recognized by its one
octet value that is greater than or equal to 224 (0xE0), and less than 255 (0xFF)."
<pre>
  new-header-P  :=  new-tag  new-len-P

  new-tag       :=  11xxxxxx

  new-len-P     :=  111xxxxx
</pre>
<p>


<h3> pkt-body </h3>

The internal format of a pkt-body depends on the packet type.
Each type of packet has a unique format for its pkt-body.
The various packet types and their formats are specified in subsequent sections.
<p>

<h3> partial-body </h3>

Unlike a pkt-body, a partial-body has no internal format.
It is simply a block of bytes.
The concatenation of all the partial-body blocks in a compound-packet
form a single body of data.
<p>

<br>
<hr color="#00FF00">
<!----------------------------------------------------------------------------->
<h2> CB-packet </h2>

The CB-packet is the <i>literal data packet</i>.
<br>[See RFC-4880 section 5.9]
<p>

The CB-packet contains unencrypted and uncompressed data.
This is usually the first packet to be assembled at the transmitter,
and the last to be disassembled at the receiver.
It may contain any type of data or file:
a text file, an mp3 file, a jpg file, etc.
<p>

<h3> Grammar </h3>
<pre>
  CB-packet := 
      pkt-header
      data-type
      fname-len
      fname-str
      file-time
      ltrl-data

  data-type  :=  0x62 | 0x74 | 0x75

  fname-len  :=  XX

  fname-str  :=  XX XX ... XX

  file-time  :=  XX XX XX XX

  ltrl-data  :=  XX XX XX XX ... XX XX XX
</pre>
<p>

<code>data-type</code>
is a one-byte value that specifes the type of data in ltrl-data.
There are three types.
Binary data is specified by the 'b' char (0x62).
Text data is specified by the 't' char (0x74).
UTF-8 text data is specified by the 'u' char (0x75).
<p>

<code>fname-len</code>
is a one-byte value that specifis the length of the subsequent fname-str.
This means that the filename must be less than 256 characters.
The filename may also be a zero-length string.
<p>

<code>fname-str</code>
is a multiple-byte value that usually specifies a filename.
Commonly, if the source of the encrypted data is a file, 
this will be the name of the encrypted file.
If the special filename "_CONSOLE" is used, 
then the message is considered to be <i>For Your Eyes Only</i>
and the receiver should process it accordingly.
<p>

<code>file-time</code>
is a four-byte value that indicates the time the file was created.
The value represents the number of seconds elapesd since Epoch 1970.
<p>

<code>ltrl-data</code>
is a multiple-byte value that repesents the literal data.
Text data is stored with CR-LF line endings.
The receiver should convert these to native line endings.
Binary data requires no such conversion.
<p>

<h3> Example </h3>
<pre>
  pkt-header    CB FF 00 00 00 D7
  data-type     62
  fname-len     0B
  fname-str     65 78 61 6d 70 6c 65 2e 74 78 74
  file-time     4C BE 3C AD
  ltrl-data     54 68 65 20 43 42 2d 70 61 63 6b 65 74 20 63 6f 
                6e 74 61 69 6e 73 20 75 6e 65 6e 63 72 79 70 74
                65 64 20 61 6e 64 20 75 6e 63 6f 6d 70 72 65 73
                73 65 64 20 64 61 74 61 2e 20 54 68 69 73 20 69
                73 20 74 68 65 20 66 69 72 73 74 20 70 61 63 6b
                65 74 20 74 6f 20 62 65 20 61 73 73 65 6d 62 6c
                65 64 20 77 68 65 6e 20 74 72 61 6e 73 6d 69 74
                74 69 6e 67 20 61 20 6d 65 73 73 61 67 65 2c 20
                61 6e 64 20 69 74 20 69 73 20 74 68 65 20 6c 61
                73 74 20 70 61 63 6b 65 74 20 74 6f 20 62 65 20
                64 69 73 61 73 73 65 6d 62 6c 65 64 20 77 68 65
                6e 20 72 65 63 65 69 76 69 6e 67 20 61 20 6d 65
                73 73 61 67 65 2e 
</pre>
<p>

The example shows a CB-packet that contains literal data.
The pkt-header field specifies a CB-packet with a body length of 215 bytes.
The data-type field signifies that the data is in binary format.
The fname-len field is the length of the string in the fname-str field.
The fname-str field is the 11 byte ASCII string "example.txt".
The file-time field specifies the time that the file was last modified.
Finally, the ltrl-data field contains 198 bytes of binary data.
<p>

<br>
<hr color="#00FF00">
<!----------------------------------------------------------------------------->
<h2> C8-packet </h2>

The C8-packet is the <i>compressed data packet</i>.
<br>[See RFC-4880 section 5.6]
<p>

The C8-packet contains compressed data.
In many cases, a C8-packet encapsulates a literal data packet (CB-packet),
and the C8-packet itself is encapsulated inside a symmetrically encrypted 
data packet (C9-packet).
In these cases, an entire CB-packet is compressed
and the result inserted into the body of a C8-packet.
Then this C8-packet is encrypted and the result 
inserted into the body of a C9-packet.
<p>


<h3> Grammar </h3>
<pre>
  C8-packet := 
      pkt-header
      compr-alg
      compr-data

  compr-alg  :=  00 | 01 | 02 | 03

  compr-data :=  XX XX XX XX ... XX XX XX
</pre>
<p>

<code>compr-alg</code>
is a one-byte value that signifies a data compression algorithm.
OpenPGP supports three compression algorithms: ZIP, ZLIB, and BZip2.
The codes for these are 00=None, 01=ZIP, 02=ZLIB, and 03=BZip2.
<p>

<code>compr-data</code>
is a multi-byte value that represents the compressed data.
The three different compression algoritms are discussed 
in the "Compression algorithms" section below.
<p>

<h3> Example </h3>
<pre>
  pkt-header    C8 FF 00 00 01 01
  compr-alg     01
  compr-data    D1 57 13 48 C9 A7 F0 EC F1 D3 58 C2 61 C6 A9 6F 
                25 CC 8B 3F 1B 3A C4 C3 C8 EA 88 AE A1 D3 A9 6B 
                92 50 E8 9A 11 B3 66 10 F7 BD DA 35 55 85 8B 64 
                AF 73 9C 8C 79 31 93 0D 43 C4 F3 CA 12 06 DD 1C 
                29 FE D3 FF 09 1F F5 94 EF EA B0 F9 53 3F DC 45 
                A8 70 4B 80 19 F3 04 D3 BA CF DD AF 36 67 70 BC 
                A5 4F BE 33 AE 89 56 00 31 E7 BF 30 61 60 D9 0C 
                FF 74 82 8D 64 65 DE 1D 2F E1 C2 5E 15 11 42 35 
                13 48 C0 71 80 63 58 34 21 CC B7 BC E0 66 1C 1A 
                87 60 B4 41 C9 2E D9 3F 20 D5 4D FE 7F 7E 2F 79 
                7F 0B F0 C1 EC CC 1C E9 A5 2D 10 85 5F AA F7 DA 
                05 67 3A 0A 6E E2 25 0D 04 BC FB CB 63 74 FB 1F 
                F4 86 04 F4 D4 B8 EF 23 24 22 5B 4E 7B 4F DC 85 
                83 30 5A 6F 9E 4B 1E F8 CE 08 93 0F B7 29 89 B5 
                B8 4B 27 C3 7E E7 07 0D F4 04 31 22 50 16 ED 9F 
                1C 39 0E 06 84 D0 52 98 B8 07 BB 49 6B 99 2C 53 
</pre>
<p>

The example shows a C8-packet that contains compressed data.
The pkt-header field specifies a C8-packet with a body length of 257 bytes.
The compr-alg field specifies the ZIP algorithm.
The compr-data field is 256 bytes of ZIP compressed data.
<p>

<br>
<hr color="#00FF00">
<!----------------------------------------------------------------------------->
<h2> C4-packet </h2>

The C4-packet is the <i>one-pass signature packet</i>.
<br>[See RFC-4880 section 5.4]
<p>

The C4-packet precedes the openpgp-message to be signed and the subsequent C2-packet.
The C4-packet and the C2-packet bracket the openpgp-message which is hashed and signed.
(Refer to the grammar for a signed-message.)
The actual signature value is in the C2-packet.
<p>

<h3> Grammar </h3>
<pre>
  C4-packet :=
      version-no
      signet-type
      hash-alg
      pub-key-alg
      pub-key-id
      last-C4
</pre>

<code>version-no</code>
is a one-byte value that signifies the version of the C4-packet.
The current version is 3.
<p>

<code>signet-type</code>
is a one-byte value that signifies the signature type.
The various signature types are discussed in the "Signature types" section below.
The signature of a binary document is specified by the value 0.
<p>

<code>hash-alg</code>
is a one-byte value that specifies the message digest (hash) algorithm.
OpenPGP supports a variety of hash algorithms.
These include MD5, SHA-1, and SHA-256.
These are discussed in "Hash algorithms" section below.
The SHA-256 hash algorithm is specified by the value 8.
<p>

<code>pub-key-alg</code>
is a one-byte value that specifies the public-key algorithm.
OpenPGP supports a variety of public-key algorithms.
These include RSA, DSA, and ElGamal.
These are discussed in the "Public-key algorithms" section below.
The RSA algorithm is specified by the value 1.
<p>

<code>pub-key-id</code>
is an eight-byte (64-bit) value that represents
the public key with which the hash of the subsequent openpgp-message is signed.
It is the low-order 64 bits of the V4 fingerprint of the public key.
The V4 fingerprint is the 160-bit SHA-1 hash of the octet 0x99,
followed by the two-octet packet length, followed by the entire
public key packet (C6-packet) starting with the version field.  
<p>

<code>last-C4</code>
is a one-byte boolean value where non-zero is true and zero is false.
A non-zero value specifies that the current packet is the last C4-packet in a series,
and that the next packet is part of the openpgp-message that is signed.
The zero value #x00 specifies that the next packet is another C4-packet.
If a message contains more than one pair of C4 and C6 packets,
then each pair brackets the message.
That is, the first C4-packet corresponds to the last C2-packet,
and the last C4-packet corresponds to the first C2-packet.
<p>

<h3> Example </h3>
<pre>
  pkt-header    C4 0D
  version-no    03
  signet-type   00
  hash-alg      08
  pub-key-alg   01
  pub-key-id    8E 42 D3 1F 09 3C C7 FB
  last-C4       01
</pre>
<p>

The example shows a C4-packet that delimits an openpgp-message to be signed.
The pkt-header field is a new-header-2 that specifies a packet body length of 13.
The version-no field specifies a C4-packet of version 3.
The signet-type field specifies a simple binary signature.
The hash-alg field specifies a SHA-256 message digest.
The pub-key-alg field specifies an RSA signature on the message digest.
The pub-key-id field identifies the public key that was used 
to sign the message digest.
The last-C4 field indicates that the next packet is part of the openpgp-message.
<p>

<br>
<hr color="#00FF00">
<!----------------------------------------------------------------------------->
<h2> C2-packet </h2>

The C2-packet is the <i>signature packet</i>, aka <i>signature</i>.
<br>[See RFC-4880 section 5.2]
<p>

The C2-packet binds a public key to some data.
The most common C2-packet is the signature of the hash of a block of text.
There are two versions of the C2-packet.
A version 3 signature provides a basic format for signature information.
A version 4 signature provides an expandable format that can specify 
more information about the signature.
Implementations should accept both version 3 and version 4 signatures,
but only generate version 4 signatures.
The grammar shown below is for a version 4 signature.
<p>

OpenPGP provides a way to publish algorithm preferences: the <i>subpacket</i>.
The C2-packet may contain subpackets that supply preferences for
the symmetric algorithm, the hash algorithm, and the compression algorithm.
The preference for the asymmetric algorithm is inferred from the 
public key algorithm field in the version 4 signature.
Subpackets are optional.
The grammar for subpackets is given in RFC-4880.
<p>

<h3> Grammar </h3>
<pre>
  C2-packet :=
      pkt-header
      version-no
      signet-type
      pub-key-alg
      hash-alg
      hashed-len
      hashed-subs
      unhash-len
      unhash-subs
      hash-msw
      mpi-bits
      mpi-int

  version-no   := XX

  signet-type  := XX

  pub-key-alg  := XX

  hash-alg     := XX

  hashed-len   := XX XX

  hashed-subs  := [subpacket]...

  unhash-len   := XX XX

  unhash-subs  := [subpacket]...

  hash-msw     := XX XX

  mpi-bits     := XX XX

  mpi-int      := XX XX XX XX ... XX XX XX
</pre>
<p>

<code>version-no</code>
is a one-byte value that represents the version of the C2-packet,
i.e. the version of the signature.
Version 4 is specified by the value 4.
<p>

<code>signet-type</code>
is a one-byte value that signifies the signature type.
The various signature types are discussed in the "Signature types" section below.
The signature of a binary document is specified by the value 0.
<p>

<code>pub-key-alg</code>
is a one-byte value that specifies the public-key algorithm.
OpenPGP supports a variety of public-key algorithms.
These include RSA, DSA, and ElGamal.
These are discussed in the "Public-key algorithms" section below.
The RSA algorithm is specified by the value 1.
<p>

<code>hash-alg</code>
is a one-byte value that specifies the message digest (hash) algorithm.
OpenPGP supports a variety of hash algorithms.
These include MD5, SHA-1, and SHA-256.
These are discussed in "Hash algorithms" section below.
The SHA-256 hash algorithm is specified by the value 8.
<p>

<code>hashed-len</code>
is a two-byte value that specifies the number of bytes in the following hashed-subs field.
A value of 0 means that there are no subpackets.
<p>

<code>hashed-subs</code>
is a sequence of zero or more subpackets that are subsequently hashed.
This field is NULL if there are no subpackets.
The subpackets in this field are hashed.
The grammar for subpackets is given in RFC-4880.
<p>

<code>unhash-len</code>
is a two-byte value that specifies the number of bytes in the following unhash-subs field.
A value of 0 means that there are no subpackets.
<p>

<code>unhash-subs</code>
is a sequence of zero or more subpackets that are not subsequently hashed.
This field is NULL if there are no subpackets.
The subpackets in this field are not hashed.
The grammar for subpackets is given in RFC-4880.
<p>

<code>hash-msw</code>
is a two-byte value that represents the 16 most-significant bits of the hash value.
This hash value is computed using the hash algorithm specified in hash-alg.
The hash input is the concatenation of two sequences of data:
(1) the packets bracketed by the corresponding C4-packet and the current C2-packet, and
(2) the current C2-packet fields from the version-no field through the 
hashed-subpkts field.
<p>

<code>mpi-bits</code>
is a two-byte value that represents
the number of significant bits in the large integer value 
specified in the subsequent mpi-int field.
<p>

<code>mpi-int</code>
is a multi-byte value that represents a public-key signature of a hash value.
For a signature using the RSA algorithm, 
this is the integer s = m**d mod n, where
the integer n is the public modulus,
the integer d is the secret exponent, and 
the integer m is hash value plus some extra bytes.
The formation of the integer s is discussed in "RSA signatures" below.
<p>

<h3> Example </h3></code>
<pre>
  pkt-header    C2 FF 00 00 00 8C
  version-no    04
  signet-type   00
  pub-key-alg   01
  hash-alg      08
  hashed-len    00 00
  unhash-len    00 00
  hash-msw      7E B3
  mpi-bits      03 FF
  mpi-int       5E 47 3A 94 2B 8F CC 1A 63 5B 7E 6E 1D 4F 5F F9 
                E4 63 8C B7 60 9D 0F 63 2E 4A 5F 6E 82 49 FF 2A 
                0D 3C 31 5E 44 BC AC 99 61 D6 75 4D AF A1 56 6F 
                BC 07 BD C1 6C C3 2F 5E C4 E2 B8 9E A8 4B D7 4B 
                F2 4D 3F 64 18 D6 D6 B2 F9 8A FF 21 33 7C 26 60 
                A1 20 F7 5B C8 65 9F F9 F3 E8 CA D1 7C F6 80 14 
                29 76 AD F6 7F 3B BD 23 9E 55 78 83 C1 66 30 02 
                8B A4 56 DA AB E4 9A 21 F9 47 13 B3 1B 81 F0 60 
</pre>
<p>

The example shows a C2-packet that contains a signature of a hash.
The pkt-header field specifies a C2-packet with a pkt-body length of 140 bytes.
The version-no of 4 specifies a version 4 signature.
The signet-type of 0 specifies that the signature is on a hash of binary data.
The pub-key-alg of 1 specifies an RSA signature.
The hash-alg of 8 specifies a SHA-256 message digest.
The hashed-len of 0 specifies that there are zero hashed subpacket bytes.
The unhash-len of 0  specifies that there are zero unhashed subpacket bytes.
(Note that the hashed-subs field and the unhash-subs field are both null).
The hash-msw of 0x7EB3 provides the 16 most-significant bits of the hash.
The mpi-bits specifies that the subsequent mpi-int field has 1023 significant bits.
The mpi-int field contains a 128-byte value that is the RSA signature of a SHA-256 hash.
<p>

<br>
<hr color="#00FF00">
<!----------------------------------------------------------------------------->
<h2> C9-packet </h2>

A C9-packet is a <i>symmetrically encrypted data packet</i>.
<br>[See RFC-4880 section 5.7]
<p>

The C9-packet contains data that has been encrypted with a symmetric key algorithm.
When it has been decrypted, it will usually contain one or more other packets.
<p>

<h3> Grammar </h3>
<pre>
  C9-packet := 
      pkt-header
      cipher-text

  cipher-text := XX XX XX ... XX XX
</pre>
<p>

<code>cipher-text</code>
is a multi-byte value that represents data that is encrypted 
using a symmetric encryption algorithm.
The symmetric encryption algorithm and the corresponding session key 
are specified in a packet that precedes the C9-packet.
The length of cipher-text will be a multiple of the algorithm's block length.
For example, AES-128 in CFB mode generates 16-byte blocks (128 bits), 
which means that the length of the cipher-text field will be a multiple of 16.
<p>
OpenPGP supports a variety of symmetric encryption algorithms.
These include IDEA, Triple DES, and AES-128.
These are discussed in the "Symmetric algorithms" section below.
OpenPGP also requires the use of a variant of Cipher Feedback Mode (CFB).
This is specified in the "OpenPGP CFB mode" section below.
<p>

<h3> Example </h3>
<pre>
  pkt-header    C9 FF 00 00 00 F0
  cipher-text   8B 4D F2 10 25 BB 04 FC A8 22 73 18 13 B0 35 1F 
                D3 41 DF 44 72 0A 50 DF 16 E4 07 2D 4B 0A F9 BE 
                7D 46 C2 4C 1C 63 15 D8 CC 7F B1 01 52 FB CE A2 
                62 7E 4F 92 58 F6 AC 4E 0E 3D 05 3F 59 61 16 CE 
                6B 32 4C A9 37 87 47 CE AC 2A 58 10 1F CA A8 4F 
                E5 31 19 48 A5 6C 2E 55 70 A9 31 85 4B FB A7 23 
                FB 50 89 49 21 56 C0 A5 54 09 91 67 32 EF DE 05 
                AE 13 76 98 7D 89 6E 2D 90 04 5E D8 32 32 D3 2B 
                95 42 B9 37 5D F6 3A 13 BC 21 18 00 66 CA E8 05 
                2A B5 20 97 C2 EC BF 57 CB 60 FB 37 DD BD E9 20 
                29 DE 57 C3 56 C3 AD 12 96 8B 29 04 B3 C0 5E 13 
                75 8C 1D A1 F5 A9 13 5B 1F E9 A4 5B 1F F8 2B AA 
                F2 64 AC 53 A2 A0 D0 DD 9F 0E 65 39 10 A6 99 0B 
                5D 7E F7 29 9D 3B D4 ED B2 4E 3D 5F 80 46 01 FC 
                41 87 3F 49 76 A9 20 ED 56 79 96 AA B1 8A 26 2E 
</pre>

The example shows a C9-packet that contains symmetrically encrypted data.
The pkt-header field specifies a C9-packet with a body length of 240 bytes.
The cipher-text field contains fifteen 128-bit blocks,
the output of AES-128 in CFB mode.
<p>

<br>
<hr color="#00FF00">
<!----------------------------------------------------------------------------->
<h2> C1-packet </h2>  

The C1-packet is the <i>public key encrypted session key packet</i>.
<br>[See RFC-4880 section 5.1]
<p>

The C1-packet contains a session key.
This session key has been encrypted with the receiver's public key.
For example, Bob wishes to send a message to Alice.
He writes the message, selects a random 128-bit integer as an AES session key,
encrypts the message with this key, and inserts the results into a C9-packet.
Then he encrypts the AES session key with the Alice's 1024-bit RSA
public encryption key and inserts the 1024-bit result into a C1-packet.
The C1-packet is transmitted first, followed by the C9-packet.
Alice uses her RSA private decryption key to decrypt 
the AES session key in the C1-packet.
Then she uses this AES session key to decrypt the message in the C9-packet.
<p>

<h3> Grammar </h3>
<pre>
  C1-packet := 
      pkt-header
      version-no
      pub-key-id
      pub-key-alg
      mpi-bits
      mpi-int

  version-no  := 03

  pub-key-id  := XX XX XX XX XX XX XX XX

  pub-key-alg :=  XX

  mpi-bits    := XX XX

  mpi-int     := XX XX XX XX ... XX XX XX
</pre>
<p>

<code>version-no</code>
is a one-byte value that represents the version of the C1-packet.
The current version is 3.
<p>

<code>pub-key-id</code>
is an eight-byte (64-bit) value that represents
the public key with which the session key is encrypted.
It is the low-order 64 bits of the V4 fingerprint of the public key.
The V4 fingerprint is the 160-bit SHA-1 hash of the octet 0x99,
followed by the two-octet packet length, followed by the entire
public key packet (C6-packet) starting with the version field.  
<p>
A pub-key-id value of zero (i.e. eight zero bytes) is the "wild-card" pub-key-id.
This is where the receiver must try all available private keys and 
check for a valid decrypted session key. The wild-card value 
helps to reduce traffic analysis of messages.
<p>

<code>pub-key-alg</code>
is a one-byte value that specifies the public-key algorithm.
OpenPGP supports a variety of public-key algorithms.
These include RSA, DSA, and ElGamal.
These are discussed in the "Public-key algorithms" section below.
The C1-packet grammar shown above assumes the RSA algorithm.
The RSA algorithm is specified by the value 1.
<p>

<code>mpi-bits</code>
is a two-byte value that represents
the number of significant bits in the subsequent mpi-int field.
<p>

<code>mpi-int</code>
is a multi-byte value that represents a public-key encryption of a session key.
For an encryption using the RSA algorithm, 
this is the integer c = m**e mod n, where
the integer n is the public modulus,
the integer e is the public exponent, and 
the integer m is the session key plus some extra bytes.
The formation of the integer m is discussed in "RSA encryptions" below.
<p>

<h3> Example </h3>
<pre>
  pkt-header    C1 FF 00 00 00 8C
  version-no    03
  pub-key-id    00 00 00 00 00 00 00 00
  pub-key-alg   01
  mpi-bits      04 00
  mpi-int       DB AA 7E 7B 2F 73 AF FA 08 DC 86 56 9D 16 DA 02
                D7 24 4E 39 94 FE 2B 1B 21 4B 54 1F CE 84 CE 50
                F6 BF 18 72 91 C7 6A EE C4 2C ED F3 0C AD 6A E7
                9C 3D 52 EA E5 DD 74 55 18 78 02 B7 08 55 98 F0
                EB 52 E9 B0 75 FD 00 CC E1 4F DC 0D 1C 20 CC CF
                30 60 59 C1 39 4C E2 65 B6 05 B1 65 83 3E 41 11
                6C 4B E2 F3 6D 7C 14 81 8F 6E 11 1F E4 41 36 54
                BE 47 B5 E3 8B BD 94 BF B7 9B 4F E5 22 BC 34 A1 
</pre>
<p>

The example shows a C1-packet that contains a 1024 RSA-encrypted session key.
The pkt-header field specifies a C1-packet with a body length of 140 bytes.
The version-no field specifies a version 3 C1-packet.
The pub-key-id field has the wild-card value.
The pub-key-alg field specifies the RSA algorithm.
The mpi-bits field specifies the number of bits in the mpi-int field, 
in this case 1024.
The mpi-int field contains 128 bytes of RSA-encrypted session key.
<p>

<br>
<hr color="#00FF00">
<!----------------------------------------------------------------------------->
<h2> CD-packet </h2>

The CD-packet is the <i>user id packet</i>.
<br>[See RFC-4880 section 5.11]
<p>

The CD-packet contains an identification string.
The string identifies the owner of a public key.
The string consists of UTF-8 characters.
<p>

<h3> Grammar </h3>
<pre>
  CD-packet := 
      pkt-header
      utf-8-str

  utf-8-str := XX XX ... XX
</pre>

<code>utf-8-str</code>
is a multi-byte value that represents a string consisting of UTF-8 characters.
By convention, the string includes an RFC 2822 mail name-addr.
<p>

<h3> Example </h3>
<pre>
  pkt-header    CD FF 00 00 00 1E
  utf-8-str     42 6F 62 20 42 6F 6E 65 68 65 61 64 20 3C 62 6F
                62 40 65 78 61 6D 70 6C 65 2E 6F 72 67 3E
</pre>

The example shows a CD-packet that contains an identification string.
The utf-8-str field is "Bob Bonehead &lt;bob@example.org&gt;".
The length of this string is 30 bytes.
<p>

<br>
<hr color="#00FF00">
<!----------------------------------------------------------------------------->
<h2> C6-packet </h2>

The C6-packet is the <i>public key packet</i>.
<br>[See RFC-4880 section 5.5]
<p>

The C6-packet contains a public key.
The RSA version of the C6-packet is shown in the grammar and example below.
It contains the two components of an RSA public key: the modulus and the encryptor.
Once Bob publishes his public encryption key and or his public signature key
in a C6-packet, Alice can subsequently transmit encrypted messages to Bob, 
or verify signed messages from Bob.
<p>

<h3> Grammar </h3>
<pre>
  C6-packet := 
      pkt-header
      version-no
      key-time
      pub-key-alg
      mpi-bits
      mpi-int
      mpi-bits
      mpi-int

  version-no  :=  XX

  key-time    :=  XX XX XX XX

  pub-key-alg :=  XX

  mpi-bits    :=  XX XX

  mpi-int     :=  XX XX XX ... XX XX
</pre>
<p>

<code>version-no</code>
is a one-byte value that represents the version of the C6-packet.
There are two versions: version 3 and version 4.  V3 keys are deprecated.
OpenPGP implementations must create C6-packets in version 4.
<p>

<code>key-time</code>
is a four-byte value that indicates the time the key was created.
The value represents the number of seconds elapesd since Epoch 1970.
<p>

<code>pub-key-alg</code>
is a one-byte value that specifies the public-key algorithm.
OpenPGP supports a variety of public-key algorithms.
These include RSA, DSA, and ElGamal.
These are discussed in the "Public-key algorithms" section below.
The C6-packet grammar shown above assumes the RSA algorithm.
The RSA algorithm is specified by the value 1.
<p>

<code>mpi-bits</code>
is a two-byte value that represents
the number of significant bits in the large integer value 
specified in the subsequent mpi-int field.
<p>

<code>mpi-int</code>
is a multi-byte value that represents a large integer.
The C6-packet shown above contains two mpi-int values.
The first is for an RSA modulus and the second is for an RSA exponent.
<p>

<h3> Example </h3>
<pre>
  pkt-header    C6 FF 00 00 01 0A
  version-no    04
  key-time      4D 31 F5 1E
  pub-key-alg   01
  mpi-bits      04 00
  mpi-int       FF 76 76 15 77 42 38 14 68 4C 4D 4C 3B 70 FF 47 
                D0 16 3E AD AB 4B D4 1C 40 B6 72 76 3A 86 B4 97 
                72 29 D9 33 E9 04 66 D6 47 C9 65 48 5E 28 8A 29 
                B3 D6 40 33 44 40 8D EC 8A C0 4D 8D 85 6D 66 99 
                15 BD 5B E8 E9 4A 4E 68 7D 36 57 4A FB 02 4E 59 
                38 46 1A B8 2E 57 52 37 1E AC BE 38 04 D0 13 A8 
                BA BB 69 EF F7 73 63 F5 8A 58 D8 0C 1B 0C 0C 67 
                68 82 26 5E FC 69 0C DB 9F 48 BC 4D A8 0D 62 6B 
  mpi-bits      03 FF
  mpi-int       43 79 A8 EF E4 85 4B DD A2 D8 C5 1D C6 79 22 5A 
                FC 26 BE B3 C1 43 D7 44 4C 9F FA D6 B2 13 C5 11 
                0B 1A FB BB C4 DD 52 A2 E2 81 4F 11 E5 13 98 93 
                E2 3C 5F 51 AD 20 68 AF 14 E3 1E 25 CA DA 51 28 
                58 01 6B 90 EC 81 BE D0 64 9B DD 6D 2C A4 F6 0B 
                B4 BD 40 C3 B2 86 A2 72 28 BB 4B DD 89 99 CF 0C 
                45 12 11 3C C5 F7 CF D2 F6 E8 4B 87 9B 64 C6 74 
                85 16 67 19 71 F4 3B 9E A0 8A 82 C2 53 32 47 EB 
</pre>
<p>

The example shows a C6-packet that contains an RSA public key consisting of
a 1024-bit RSA modulus and a 1023-bit RSA exponent.
The pkt-header field specifies a C6-packet with a body length of 266 bytes.
The version-no field specifies a version 4 public key.
The key-time field specifies the time that the RSA key was created.
The pub-key-alg field specifies the RSA algorithm.
The first mpi-bits field specifies that the RSA modulus has 1024 bits.
The first mpi-int field is 128 bytes and specifies the value of the RSA modulus.
The second mpi-bits field specifies that the RSA exponent has 1023 bits.
The second mpi-int field is 128 bytes and specifies the value of the RSA exponent.
<p>

<br>
<hr color="#00FF00">
<!----------------------------------------------------------------------------->
<h2> C5-packet </h2>

The C5-packet is the <i>secret key packet</i>.
<br>[See RFC-4880 section 5.5.3]
<p>

The C5-packet contains a secret key.
The RSA version of the C5-packet is shown in the grammar and example below.
<p>

<pre>
$ pgpdump zeta-private.pgp 
Old: Secret Key Packet(tag 5)(510 bytes)
version-no	Ver 4 - new
key-time	Public key creation time - Tue Feb  8 15:47:46 MST 2011
pub-key-alg	Pub alg - RSA Encrypt or Sign(pub 1)
mpi-int 	RSA n(1024 bits) - ...
mpi-int 	RSA e(17 bits) - ...
sym-key-alg	Sym alg - CAST5(sym 3)
s2k-spec	Iterated and salted string-to-key(s2k 3):
		Hash alg - SHA1(hash 2)
		Salt - d3 0e 0c 82 50 d8 76 f8 
		Count - 65536(coded count 96)
s2k-vector	IV - 9f ea b3 6c 04 ae 41 0f 
mpi-int 	Encrypted RSA d
mpi-int 	Encrypted RSA p
mpi-int 	Encrypted RSA q
mpi-int 	Encrypted RSA u
s2k-hash	Encrypted SHA1 hash
</pre>



<h3> Grammar </h3>
<pre>
  C5-packet := 
      pkt-header
      version-no
      key-time
      pub-key-alg
      mpi-bits
      mpi-int
      mpi-bits
      mpi-int

  version-no  :=  XX

  key-time    :=  XX XX XX XX

  pub-key-alg :=  XX

  mpi-bits    :=  XX XX

  mpi-int     :=  XX XX XX ... XX XX
</pre>
<p>

<code>version-no</code>
is a one-byte value that represents the version of the C5-packet.
There are two versions: version 3 and version 4.  V3 keys are deprecated.
OpenPGP implementations must create C5-packets in version 4.
<p>

<code>key-time</code>
is a four-byte value that indicates the time the key was created.
The value represents the number of seconds elapesd since Epoch 1970.
<p>

<code>pub-key-alg</code>
is a one-byte value that specifies the public-key algorithm.
OpenPGP supports a variety of public-key algorithms.
These include RSA, DSA, and ElGamal.
These are discussed in the "Public-key algorithms" section below.
The C5-packet grammar shown above assumes the RSA algorithm.
The RSA algorithm is specified by the value 1.
<p>

<code>mpi-bits</code>
is a two-byte value that represents
the number of significant bits in the large integer value 
specified in the subsequent mpi-int field.
<p>

<code>mpi-int</code>
is a multi-byte value that represents a large integer.
The C5-packet shown above contains two mpi-int values.
The first is for an RSA modulus and the second is for an RSA exponent.
<p>

<h3> Example </h3>
<pre>
  pkt-header    C5 FF 00 00 01 0A
  version-no    04
  key-time      4D 31 F5 1E
  pub-key-alg   01
  mpi-bits      04 00
  mpi-int       FF 76 76 15 77 42 38 14 68 4C 4D 4C 3B 70 FF 47 
                D0 16 3E AD AB 4B D4 1C 40 B6 72 76 3A 86 B4 97 
                72 29 D9 33 E9 04 66 D6 47 C9 65 48 5E 28 8A 29 
                B3 D6 40 33 44 40 8D EC 8A C0 4D 8D 85 6D 66 99 
                15 BD 5B E8 E9 4A 4E 68 7D 36 57 4A FB 02 4E 59 
                38 46 1A B8 2E 57 52 37 1E AC BE 38 04 D0 13 A8 
                BA BB 69 EF F7 73 63 F5 8A 58 D8 0C 1B 0C 0C 67 
                68 82 26 5E FC 69 0C DB 9F 48 BC 4D A8 0D 62 6B 
  mpi-bits      03 FF
  mpi-int       43 79 A8 EF E4 85 4B DD A2 D8 C5 1D C6 79 22 5A 
                FC 26 BE B3 C1 43 D7 44 4C 9F FA D6 B2 13 C5 11 
                0B 1A FB BB C4 DD 52 A2 E2 81 4F 11 E5 13 98 93 
                E2 3C 5F 51 AD 20 68 AF 14 E3 1E 25 CA DA 51 28 
                58 01 6B 90 EC 81 BE D0 64 9B DD 6D 2C A4 F6 0B 
                B4 BD 40 C3 B2 86 A2 72 28 BB 4B DD 89 99 CF 0C 
                45 12 11 3C C5 F7 CF D2 F6 E8 4B 87 9B 64 C6 74 
                85 16 67 19 71 F4 3B 9E A0 8A 82 C2 53 32 47 EB 
</pre>
<p>

The example shows a C5-packet that contains an RSA public key consisting of
a 1024-bit RSA modulus and a 1023-bit RSA exponent.
The pkt-header field specifies a C5-packet with a body length of 266 bytes.
The version-no field specifies a version 4 public key.
The key-time field specifies the time that the RSA key was created.
The pub-key-alg field specifies the RSA algorithm.
The first mpi-bits field specifies that the RSA modulus has 1024 bits.
The first mpi-int field is 128 bytes and specifies the value of the RSA modulus.
The second mpi-bits field specifies that the RSA exponent has 1023 bits.
The second mpi-int field is 128 bytes and specifies the value of the RSA exponent.
<p>

<br>
<hr color="#00FF00">
<!----------------------------------------------------------------------------->
<h2> RSA encryptions </h2>

The C1-packet includes the mpi-int field,
a multi-byte value that represents a public-key encryption of a session key.
For an encryption using the RSA algorithm, this is the integer c = m**e mod n,
where the integer n is the public modulus, the integer e is the public exponent,
and the integer m is the session key plus some extra bytes.
The integer m is specified as follows.
<p>

<h3> Grammar </h3>
<pre>
  m :=  padding-hdr
        padding-str
        padding-end
        symm-alg
        session-key
        checksum

  padding-hdr :=  00 02

  padding-str :=  XX XX XX ... XX XX

  padding-end :=  00

  symm-alg    :=  XX

  session-key :=  XX XX XX ... XX XX

  checksum    :=  XX XX
</pre>
<p>


<code>padding-hdr</code>
is a two-byte value that precedes the padding-str.
The two values are 00 and 02.
<p>

<code>padding-str</code>
is a multi-byte value that pads the session key so that the 
integer m is almost as large as the modulus integer n.
The bytes are typically selected using a random number generator.
The number of bytes depends on the number of bytes in the modulus.
Note that the byte 00 is not allowed.
<p>

<code>padding-end</code>
is a one-byte value that follows the padding-str.
The value is 00.
<p>

<code>symm-alg</code>
is a one-byte value that specifies the algorithm 
that will use the session-key in the next field to symmetrically encrypt data.
The AES-128 algorithm is specified by the value 7.
Other values are listed in "Symmetric algorithms" below.
<p>

<code>session-key</code>
is a multi-byte value that represents the the session key.
This value is typically selected using a random number generator.
The number of bytes in the session key depends on the symmetric algorithm.
For example, an AES-128 session key is 16 bytes.
<p>

<code>checksum</code>
is a two-byte value that is equal to the modulo 65536 sum of the session-key bytes.
For example, if an AES-128 session-key is all one's, then the checksum is 16 * 255
and the two checksum bytes are 0F and F0.
<p>

<h3> Example </h3>
<pre>
  padding-hdr    00 02
  padding-str    5E 47 3A 94 2B 8F CC 1A 63 5B 7E 6E 1D 4F 5F F9 
                 A1 20 F7 5B C8 65 9F F9 F3 E8 CA D1 7C F6 80 14 
                 29 76 AD F6 7F 3B BD 23 9E 55 78 83 C1 66 30 02 
                 8B A4 56 DA AB E4 9A 21 F9 47 13 B3 1B 81 F0 60 
                 59 79 CC 67 57 1F 1E 8F 61 FA E0 4D A9 AA 4A 33 
                 D0 90 4C 82 CF 6D C8 34 AF DD 99 A9 B4 14 9E F2 
                 38 7D D8 D1 31 B4 F5 42 F8 EB
  padding-end    00
  symm-alg       07
  session-key    E4 63 8C B7 60 9D 0F 63 2E 4A 5F 6E 82 49 FF 2A
  checksum       07 32
</pre>

The example shows the details of integer m before it is encrypted.
It contains 128 bytes because the modulus n is 1024 bits = 128 bytes.
The 8 most-significant bits of m are 0.
This insures that integer m will be less than the modulus n.
The padding-str is 106 bytes of random data.
The session-key is 16 bytes.
The remaining fields are 6 bytes.
<p>

<br>
<hr color="#00FF00">
<!----------------------------------------------------------------------------->
<h2> RSA signatures </h2>

The C2-packet includes the mpi-int field,
a multi-byte value that represents a public-key signature of a hash value.
For a signature using the RSA algorithm, this is the integer s = m**d mod n,
where the integer n is the public modulus, the integer d is the secret exponent,
and the integer m is hash value plus some extra bytes.
The integer m is specified as follows.
<p>

<h3> Grammar </h3>
<pre>
  m :=
      padding-hdr
      padding-str
      padding-end
      hash-info
      hash-value

  hash-info := 
      info-MD5    |
      info-RIPEMD |
      info-SHA1   |
      info-SHA224 |
      info-SHA256 |
      info-SHA384 |
      info-SHA512

  hash-value :=
      value-MD5    |
      value-RIPEMD |
      value-SHA1   |
      value-SHA224 |
      value-SHA256 |
      value-SHA384 |
      value-SHA512 |

  padding-hdr  :=  00 01

  padding-str  :=  XX XX XX ... XX XX

  padding-end  :=  00

  info-MD5     :=  30 20 30 0C 06 08 2A 86 48 86 F7 0D 02 05 05 00 04 10

  info-RIPEMD  :=  30 21 30 09 06 05 2B 24 03 02 01 05 00 04 14

  info-SHA1    :=  30 21 30 09 06 05 2B 0E 03 02 1A 05 00 04 14

  info-SHA224  :=  30 31 30 0D 06 09 60 86 48 01 65 03 04 02 04 05 00 04 1C

  info-SHA256  :=  30 31 30 0D 06 09 60 86 48 01 65 03 04 02 01 05 00 04 20

  info-SHA384  :=  30 41 30 0D 06 09 60 86 48 01 65 03 04 02 02 05 00 04 30

  info-SHA512  :=  30 51 30 0D 06 09 60 86 48 01 65 03 04 02 03 05 00 04 40

  value-MD5    :=  XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX

  value-RIPEMD :=  XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX
                   XX XX XX XX

  value-SHA1   :=  XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX
                   XX XX XX XX

  value-SHA224 :=  XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX
                   XX XX XX XX XX XX XX XX XX XX XX XX

  value-SHA256 :=  XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX
                   XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX

  value-SHA384 :=  XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX
                   XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX
                   XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX

  value-SHA512 :=  XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX
                   XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX
                   XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX
                   XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX
</pre>
<p>

<code>padding-hdr</code>
is a two-byte value that precedes the padding-str.
The two values are 00 and 01.
<p>

<code>padding-str</code>
is a multi-byte value that pads the session key so that the 
integer m is almost as large as the modulus integer n.
The bytes are typically selected using a random number generator.
The only exception is that the value 0 cannot be used.
The number of bytes depends on the number of bytes in the hash-info
and the hash-value.
<p>

<code>padding-end</code>
is a one-byte value that follows the padding-str.
The value is 00.
<p>

<code>hash-info</code>
is a multi-byte value that specifies the hash algorithm.
The hash-info values are predefined for various hash algorithms.
The hash-info for the SHA-256 algorithm is 19 bytes:
<code>30 31 30 0D 06 09 60 86 48 01 65 03 04 02 01 05 00 04 20</code>.
<p>

<code>hash-value</code>
is a multi-byte value that represents a value generated by a hash function.
The length of the hash-value depends on the hash algorithm.
The SHA-256 hash-value is 256 bits (32 bytes).
<p>

<h3> Example </h3>
<pre>
  padding-hdr   00 01
  padding-str   2C ED F3 0C AD 6A E7 9C 3D 52 EA E5 DD 74 55 18 
                78 02 B7 08 55 98 F0 EB 52 E9 B0 75 FD 00 CC E1 
                4F DC 0D 1C 20 CC CF 30 60 59 C1 39 4C E2 65 B6 
                05 B1 65 83 3E 41 11 6C 4B E2 F3 6D 7C 14 81 8F 
                6E 11 1F E4 41 36 54 BE 47 B5
  padding-end   00
  hash-info     30 31 30 0D 06 09 60 86 48 01 65 03 04 02 01 05
                00 04 20
  hash-value    7E EC 5A 01 84 E4 A3 56 AE C0 DA F3 CF 13 C3 2A 
                D8 E8 EF 9F 28 F2 61 AE 40 EB 5F 6E E7 71 FC D7 
</pre>

The example shows the details of integer m before it is signed.
It contains 128 bytes because the modulus n is 1024 bits = 128 bytes.
The 8 most-significant bits of m are 0.
This insures that integer m will be less than the modulus n.
The padding-hdr and padding-end are 3 bytes.
The padding-str is 74 bytes of random data.
The hash-info is 19 bytes.
The hash-value is 32 bytes.
<p>

<br>
<hr color="#00FF00">
<!----------------------------------------------------------------------------->
<h2> Compression algorithms </h2>

OpenPGP supports three compression algorithms.
The table below provides the hexadecimal integers that specify these.
Implementations <i>must</i> support uncompressed data,
<i>should</i> support ZIP, and 
<i>may</i> support any other algorithm.

<pre>
  <u>XX</u>    <u>Algorithm</u>     <u>Specification</u>
  00    Uncompr.      N/A
  01    ZIP           RFC-1951
  02    ZLIB          RFC-1950
  03    Bzip2         http://www.bzip.org
</pre>
<p>

<br>
<hr color="#00FF00">
<!----------------------------------------------------------------------------->
<h2> Symmetric algorithms </h2>

OpenPGP supports eight symmetric encryption algorithms.
The table below provides the hexadecimal integers that specify these.
Implementations <i>must</i> support TripleDES,
<i>should</i> support AES-128 and CAST5,
and <i>should</i> support IDEA in order to interoperate with PGP 2.6 or earlier.
Implementations <i>may</i> support any other algorithm.

<pre>
  <u>XX</u>    <u>Algorithm</u>     <u>Specification</u>
  00    Unencr.       N/A
  01    IDEA          -
  02    TripleDES     -
  03    CAST5         RFC-2144
  04    Blowfish      -
  07    AES-128       NIST FIPS PUB 197
  08    AES-192       NIST FIPS PUB 197
  09    AES-256       NIST FIPS PUB 197
  0A    Twofish       -
</pre>
<p>

<br>
<hr color="#00FF00">
<!----------------------------------------------------------------------------->
<h2> Public-key algorithms </h2>

OpenPGP supports three public-key encryption algorithms.
The table below provides the hexadecimal integers that specify these.
Implementations <i>should</i> support RSA.
Implementations <i>must</i> support Elgamal for encryption,
and DSA for signatures.

<pre>
  <u>XX</u>    <u>Algorithm</u>     <u>Specification</u>
  01    RSA           -
  10    Elgamal       -
  11    DSA           -
</pre>
<p>

<br>
<hr color="#00FF00">
<!----------------------------------------------------------------------------->
<h2> Hash algorithms </h2>

OpenPGP supports six message digest (hash) algorithms.
The table below provides the hexadecimal integers that specify these.
Implementations <i>must</i> support SHA-1.
Implementations <i>may</i> support other algorithms.

<pre>
  <u>XX</u>    <u>Algorithm</u>     <u>Specification</u>
  02    SHA-1         FIPS 180
  03    RIPE-MD       .
  08    SHA-256       FIPS 180
  09    SHA-384       FIPS 180
  0A    SHA-512       FIPS 180
  0B    SHA-224       FIPS 180
</pre>
<p>

<br>
<hr color="#00FF00">
<!----------------------------------------------------------------------------->
<h2> Signature types  </h2>

There are a number of possible meanings for a signature,
specified by a signature-type byte.
The table below provides the hexadecimal integers that specify these.
Most OpenPGP implementations generate type 10 generic certifications.

<pre>
  <u>XX</u>    <u>Meaning               </u>
  00    Signature of a binary document
  01    Signature of a canonical text document
  02    Standalone signature
  10    Generic certification
  11    Persona certification
  12    Casual certification
  13    Positive certification
  18    Subkey Binding Signature
  19    Primary Key Binding Signature
  1F    Signature directly on a key
  20    Key revocation signature
  28    Subkey revocation signature
  30    Certification revocation signature
  40    Timestamp signature
  50    Third-Party Confirmation signature
</pre>
<p>

<br>
<hr color="#00FF00">
<!----------------------------------------------------------------------------->
<h2> OpenPGP CFB mode </h2>

Symmetric algorithms encrypt cleartext messages in short blocks such as 128 bits.
Cleartext messages often contain well-known strings that are longer than 128 bits.
An example is an email header.  This can be a big problem.  For instance,
if a symmetric algorithm is used without some sort of block cipher mode such as CFB, 
a cryptanalyst can collect ciphertexts of email headers, compile a codebook,
and then spoof encrypted emails, all without knowing the key.
This is why a block cipher mode such as CFB is used.
<p>

<h3> Literature </h3>

CFB mode was originally used in conjunction with the 
Data Encryption Standard (DES) and is specified in
the 1980 document "DES Modes of Operation" along with
tables of examples.
[FIPS PUB 81]
<p>

Schneier discusses CFB mode in his 1994 book
"Applied Cryptography" in section 8.1.4,
and Figure 8.5 offers two block diagrams for 8-bit CFB mode,
one for encryption and the other for decryption.
[Schneier 1994]
<p>

Menezes et al discuss CFB mode in their 1996
"Handbook of Applied Cryptography" in section 7.2.2 (iii).
Figure 7.1 (c) offers two block diagrams for r-bit CFB mode,
and Algorithm 7.17 provides the details.
[HAC 1999]
<p>

CFB mode is also specified in the 2001 NIST document
"Recommendation for Block Cipher Modes of Operation"
in Section 6.3 and illustrated in Figure 3.
The document also provides example vectors for 
CFB-128 encipherment and AES-128 encryption in Appendix F.3.13 and 
CFB-128 decipherment and AES-128 encryption in Appendix F.3.14.
[NIST SP 800-38A]
<p>

<h3> Overview </h3>

A block encipherment function comprises an shift-register structure 
that is n-bits wide and shifts r-bits on every clock,
an n-bit symmetric encryption function, and an r-bit exclusive-OR function.
The n-bit shift register is initially loaded with an n-bit Initialization Vector (IV).
For every r-bit plaintext symbol, the n-bit state of the shift register
is symmetrically encrypted, the most-significant r bits of the encryption output
is exclusive-ORed with the r-bit plaintext symbol, and the r-bit exclusive-OR sum
is pushed onto the output queue.  The shift-register is clocked,
and the r-bit sum is also fed into the least-significant r bits of the shift-register.
<p>

CFB mode uses the same symmetric encryption function
in both block encipherment and block decipherment.
For example, the CFB block encipher function calls the AES-128 encryption function,
and the CFB block decipher function also calls the AES-128 encryption function.
The AES-128 decryption function is not used in CFB mode.
<p>

<h3> RFC-4880 5.7 </h3>

   "The data is encrypted in CFB mode, with a CFB shift size equal to the
   cipher's block size.  The Initial Vector (IV) is specified as all
   zeros.  Instead of using an IV, OpenPGP prefixes a string of length
   equal to the block size of the cipher plus two to the data before it
   is encrypted.  The first block-size octets (for example, 8 octets for
   a 64-bit block length) are random, and the following two octets are
   copies of the last two octets of the IV.  For example, in an 8-octet
   block, octet 9 is a repeat of octet 7, and octet 10 is a repeat of
   octet 8.  In a cipher of length 16, octet 17 is a repeat of octet 15
   and octet 18 is a repeat of octet 16.  As a pedantic clarification,
   in both these examples, we consider the first octet to be numbered 1.
<p>
   "After encrypting the first block-size-plus-two octets, the CFB state
   is resynchronized.  The last block-size octets of ciphertext are
   passed through the cipher and the block boundary is reset.

<h3> RFC-4880 13.9 </h3>

   "OpenPGP does symmetric encryption using a variant of Cipher Feedback
   mode (CFB mode).  This section describes the procedure it uses in
   detail.  This mode is what is used for Symmetrically Encrypted Data
   Packets; the mechanism used for encrypting secret-key material is
   similar, and is described in the sections above.
<p>
   "In the description below, the value BS is the block size in octets of
   the cipher.  Most ciphers have a block size of 8 octets.  The AES and
   Twofish have a block size of 16 octets.  Also note that the
   description below assumes that the IV and CFB arrays start with an
   index of 1 (unlike the C language, which assumes arrays start with a
   zero index).
<p>
   "OpenPGP CFB mode uses an initialization vector (IV) of all zeros, and
   prefixes the plaintext with BS+2 octets of random data, such that
   octets BS+1 and BS+2 match octets BS-1 and BS.  It does a CFB
   resynchronization after encrypting those BS+2 octets.
<p>
   [Note: Let PIV be the plaintext initialization vector, i.e.
   the BS+2 octets of random data that prefix the plaintext.
   The IV is a different vector and is only BS octets].
<p>
   "Thus, for an algorithm that has a block size of 8 octets (64 bits),
   the [PIV] is 10 octets long and octets 7 and 8 of the [PIV] are the same as
   octets 9 and 10.  For an algorithm with a block size of 16 octets
   (128 bits), the [PIV] is 18 octets long, and octets 17 and 18 replicate
   octets 15 and 16.  Those extra two octets are an easy check for a
   correct key.
<p>
   "Step by step, here is the procedure:
<ol>
<li>   The feedback register (FR) is set to the IV, which is all zeros.
<p>
<li>   FR is encrypted to produce FRE (FR Encrypted).  This is the
       encryption of an all-zero value.
<p>
<li>   FRE is xored with the first BS octets of random data prefixed to
       the plaintext to produce C[1] through C[BS], the first BS octets
       of ciphertext.
<p>
<li>   FR is loaded with C[1] through C[BS].
<p>
<li>   FR is encrypted to produce FRE, the encryption of the first BS
       octets of ciphertext.
<p>
<li>   The left two octets of FRE get xored with the next two octets of
       data that were prefixed to the plaintext.  This produces C[BS+1]
       and C[BS+2], the next two octets of ciphertext.
<p>
<li>   (The resynchronization step) FR is loaded with C[3] through
       C[BS+2].
<p>
<li>   FR is encrypted to produce FRE.
<p>
<li>   FRE is xored with the first BS octets of the given plaintext, now
       that we have finished encrypting the BS+2 octets of prefixed
       data.  This produces C[BS+3] through C[BS+(BS+2)], the next BS
       octets of ciphertext.
<p>
<li>   FR is loaded with C[BS+3] to C[BS + (BS+2)] (which is C11-C18 for
       an 8-octet block).
<p>
<li>   FR is encrypted to produce FRE.
<p>
<li>   FRE is xored with the next BS octets of plaintext, to produce
       the next BS octets of ciphertext.  These are loaded into FR, and
       the process is repeated until the plaintext is used up.
</ol>




<br>
<hr color="#00FF00">
<!----------------------------------------------------------------------------->
<h2> Radix-64 conversion  </h2>

"OpenPGP's underlying native representation for encrypted messages,
signature certificates, and keys is a stream of arbitrary octets.
Some systems only permit the use of blocks consisting of seven-bit,
printable text.  For transporting OpenPGP's native raw binary octets
through channels that are not safe to raw binary data, a printable
encoding of these binary octets is needed.  OpenPGP provides the
service of converting the raw 8-bit binary octet stream to a stream
of printable ASCII characters, called Radix-64 encoding or ASCII Armor.
Implementations SHOULD provide Radix-64 conversions. [RFC-4880 2.4]
<p>

"OpenPGP's Radix-64 encoding is composed of two parts: 
a base 64 encoding of the binary data and a checksum.
The base 64 encoding is identical to the MIME base64 
content-transfer-encoding. [RFC 2045]
<p>

"The checksum is a 24-bit Cyclic Redundancy Check (CRC) 
converted to four characters of radix-64 encoding 
by the same MIME base64 transformation, preceded by an equal sign (=).
The CRC is computed by using the generator 0x864CFB and an initialization of 0xB704CE.
The accumulation is done on the data before it is converted to radix-64, 
rather than on the converted data. [RFC-4880 section 6].
<p>

<h3> CRC-24 implementation </h3>
<pre>
  #define CRC24_INIT 0xB704CE
  #define CRC24_POLY 0x1864CFB
  typedef long crc24;

  crc24 crc_octets (unsigned char *octets, size_t len)
  {
    crc24 crc = CRC24_INIT;
    int i;
    while (len--)
    {
      crc ^= (*octets++) << 16;
      for (i = 0; i < 8; i++)
      {
        crc <<= 1;
        if (crc & 0x1000000)
           crc ^= CRC24_POLY;
      }
    }
    return (crc & 0xFFFFFF);
  }
</pre>


<h3> Radix-64 algorithm </h3>

Radix-64 "ASCII armor" encoding is specified in RFC 2045.
The following description of is taken from RFC 2045.
It has been slightly edited for the sake of clarity.
<p>

A 65-character subset of US-ASCII is used, enabling 6 bits to be represented 
per printable character. The extra 65th character ('=') is used to signify 
a special processing function.
<p>

The encoding process represents 24-bit groups of input bits as output strings 
of four encoded characters. Proceeding from left to right, a 24-bit input group 
is formed by concatenating three 8-bit bytes.  These 24 bits are then 
treated as four concatenated 6-bit groups, each of which is translated into a 
single ASCII digit in the base64 alphabet.
<p>

When encoding a bit stream via the base64 encoding, the bit stream
must be presumed to be ordered with the most-significant-bit first.
That is, the first bit in the stream will be the high-order bit in
the first 8-bit byte, and the eighth bit will be the low-order bit in
the first 8-bit byte, and so on.
<p>

Each 6-bit group is used as an index into an array of 64 printable characters.
The character referenced by the index is placed in the output string.
These characters, identified in the table below, are selected so as to be 
universally representable, and the set excludes characters with particular 
significance to SMTP.

<pre>
    00  A    10  Q    20  g    30  w
    01  B    11  R    21  h    31  x
    02  C    12  S    22  i    32  y
    03  D    13  T    23  j    33  z
    04  E    14  U    24  k    34  0
    05  F    15  V    25  l    35  1
    06  G    16  W    26  m    36  2
    07  H    17  X    27  n    37  3
    08  I    18  Y    28  o    38  4
    09  J    19  Z    29  p    39  5
    0A  K    1A  a    2A  q    3A  6
    0B  L    1B  b    2B  r    3B  7
    0C  M    1C  c    2C  s    3C  8
    0D  N    1D  d    2D  t    3D  9
    0E  O    1E  e    2E  u    3E  +
    0F  P    1F  f    2F  v    3F  /
</pre>

The encoded output stream must be represented in lines of no more
than 76 characters each.  All line breaks or other characters not
found in the table must be ignored by decoding software.  In base64
data, characters other than those in the table, line breaks, and other
white space probably indicate a transmission error, about which a
warning message or even a message rejection might be appropriate
under some circumstances.
<p>

Special processing is performed if fewer than 24 bits are available
at the end of the data being encoded.  A full encoding quantum is
always completed at the end of a quantity.  When fewer than 24 input
bits are available in an input group, zero bits are added (on the
right) to form an integral number of 6-bit groups.  Padding at the
end of the data is performed using the '=' character.
Since all base64 input is an integral number of octets, only the
following three cases can arise:

<ul>   
<li> The final quantum of encoding input is an integral multiple of 24 bits.
The final unit of encoded output is an integral multiple of 4 characters 
with no '=' padding.
<pre>
FF FF FF :    FF       FF       FF
         : 11111111 11111111 11111111 
         : 111111 111111 111111 111111 
         :   3F     3F     3F     3F
         : "////"
</pre>
<li> The final quantum of encoding input is exactly 16 bits.
The final unit of encoded output is three characters 
followed by one '=' padding character.
<pre>
FF FF    :    FF       FF
         : 11111111 11111111
         : 111111 111111 1111--
         :   3F     3F     3C
         :   '/'    '/'    '8'
         : "//8="
</pre>
<li> The final quantum of encoding input is exactly 8 bits.
The final unit of encoded output is two characters followed by 
two '=' padding characters.
<pre>
FF       :    FF
         : 11111111 
         : 111111 11---- ------ ------
	 :   3F     30
	 :   '/'    'w'
         : "/w=="
</pre>
</ul>
<p>

Because it is used only for padding at the end of the data, the
occurrence of any '=' characters may be taken as evidence that the
end of the data has been reached (without truncation in transit).
No such assurance is possible, however, when the number of octets
transmitted was a multiple of three and no '=' characters are present.
Any characters outside of the base64 alphabet are to be ignored in
base64-encoded data.
<p>

Care must be taken to use the proper octets for line breaks if base64
encoding is applied directly to text material that has not been
converted to canonical form.  In particular, text line breaks must be
converted into CRLF sequences prior to base64 encoding.  The
important thing to note is that this may be done directly by the
encoder rather than in a prior canonicalization step in some
implementations.
<p>

<h3> ASCII-armored public key sequence </h3>
<pre>
  -----BEGIN PGP PUBLIC KEY BLOCK-----
  Version: Blacklight 4.17

  yDgBO22WxBHv7O8X7O/jygAEzol56iUKiXmV+XmpCtmpqQUKiQrFqclFqUDBovzS
  xBHv7O8X7O/jygAEzol56iUKiXmV+XmpCtmpqQUKiQrFqclFqUDBovzSyDgBO22W
  7O/jygAEzol56iUKiXmV+XmpCtmpqQUKiQrFqclFqUDBovzSyDgBO22WxBHv7O8X
  zol56iUKiXmV+XmpCtmpqQUKiQrFqclFqUDBovzSyDgBO22WxBHv7O8X7O/jygAE
  vBSFjNSiVHsuAA==
  =njUN
  -----END PGP PUBLIC KEY BLOCK-----
</pre>
<p>

<h3> ASCII-armored encrypted data message </h3>
<pre>
  -----BEGIN PGP MESSAGE-----
  Version: Blacklight 4.17

  yDgBO22WxBHv7O8X7O/jygAEzol56iUKiXmV+XmpCtmpqQUKiQrFqclFqUDBovzS
  vBSFjNSiVHsuAA==
  =njUN
  -----END PGP MESSAGE-----
</pre>
<p>

<h3> ASCII-armored literal signature sequence </h3>
<pre>
  -----BEGIN PGP SIGNATURE-----
  Version: Blacklight 4.17

  yDgBO22WxBHv7O8X7O/jygAEzol56iUKiXmV+XmpCtmpqQUKiQrFqclFqUDBovzS
  xBHv7O8X7O/jygAEzol56iUKiXmV+XmpCtmpqQUKiQrFqclFqUDBovzSyDgBO22W
  7O/jygAEzol56iUKiXmV+XmpCtmpqQUKiQrFqclFqUDBovzSyDgBO22WxBHv7O8X
  zol56iUKiXmV+XmpCtmpqQUKiQrFqclFqUDBovzSyDgBO22WxBHv7O8X7O/jygAE
  vBSFjNSiVHsuAA==
  =njUN
  -----END PGP SIGNATURE-----
</pre>
<p>

<br>
<hr color="#00FF00">
<!----------------------------------------------------------------------------->
<h2> Miscellanea </h2>
<p>

<h3> UTF-8 </h3>

The default character set for text is the UTF-8 [RFC 2279] 
encoding of Unicode [ISO10646].
US-ASCII characters are encoded in one octet having the normal US-ASCII value, 
and any octet with such a value can only stand for an US-ASCII character, 
and nothing else.
UTP-8 character values from 0000.0000 to 0000.007F (US-ASCII repertoire) 
correspond to octets 00 to 7F (7 bit US-ASCII values). 
A direct consequence is that a plain ASCII string 
is also a valid UTF-8 string.
[RFC 2279]
<p>

<h3> Equivalent strengths </h3>

OpenPGP combines asymmetric, symmetric, and hash algorithms, 
each with different measures of strength.
Care should be taken that the weakest element of an OpenPGP message 
is still sufficiently strong for the purpose at hand.
NIST Special Publication 800-57 provides a list of equivalent strengths.
According to SP800-57, an asymmetric key size of 3072 bits (RSA-3072),
a hash size of 256 bits (SHA-256), and a symmetric key size of 128 bits (AES-128)
have equivalent strengths.
<p>

<h3> Random numbers </h3>

"Certain operations in this specification involve the use of random numbers.
An appropriate entropy source should be used to generate these numbers."
RFC 4086 discusses the problem of generating cryptographically-strong random numbers.
<p>

<br>
<hr color="#00FF00">
<!----------------------------------------------------------------------------->
<h2> Problems </h2>

We need to solve the following problems:

<ol>
<li> <b>RNG:</b><br>
What are we going to do for a random number generator?
We need good entropy sources.
We can get by temporarily by using the arc4random function,
but ultimately we need something better.
This includes reading RFC 4086 and other documents.
<p>
<li> <b>ASCII armor:</b><br>
Should we support ASCII armor?
Gmail et al provide a way to attach files, and these can be binary files.
On the other hand, it won't really be that hard to implement.
<p>
<li> <b>When to compress:</b><br>
Should I change the example in OpenPGP messages?
"OpenPGP implementations SHOULD compress the message after applying
the signature but before encryption." [RFC-4880 2.3]
The example given in OpenPGP certificates compresses before the signature.
RFC-4880 says to compress after the signature.
<p>
<li> <b>CFB mode termination:</b><br>
How is CFB mode terminated when the last block is short?
The procedure does not specify how the last octets of plaintext 
should be handled.  Most of the time a short block will occur.
Are these bytes to be shifted left? What about padding?
<p>
<li> <b>CFB mode decipherment:</b><br>
What is the algorithm for CFB decipherment?
Most sources specify both CFB encipherment and CFB decipherment.
RFC-4880 specifies only CFB encipherment, leaving CFB decipherment unspecified.
This is a non-trivial problem, as OpenPGP CFB encipherment is quite a bit
different than, say, 800-38A CFB encipherment.  
It may not be easy to derive the OpenPGP CFB decipherment algorithm.
</ol>

<br>
<hr color="#00FF00">
<!----------------------------------------------------------------------------->
<h2> Questions </h2>

We need to post the following questions on the OpenPGP forum.

<ol>
<li> <b>RSAES-PKCS1-v1_5:</b><br>
Why doesn't RFC-4880 provide for the use of RSAES-OAEP?
RFC-3447 states "Two encryption schemes are specified in this document:
RSAES-OAEP and RSAES-PKCS1-v1_5.
RSAES-OAEP is recommended for new applications;
RSAES-PKCS1-v1_5 is included only for compatibility with existing applications,
and is not recommended for new applications."
So what gives?
<p>
<li> <b>SHA-1 cracked:</b><br>
Is there any move to replace SHA-1 for V4 Key IDs?
RFC-4880 specifies that V4 Key IDs are to be computed 
using the SHA-1 algorithm.  But SHA-1 has been cracked.
<p>
<li> <b>Unused packet types:</b><br>
Why aren't all of the packet types mentioned in RFC-4880 section 11.3?
RFC-4880 section 4.3 specifies 17 unique packet types.
RFC-4880 section 11.3 specifies only some of these.
</ol>

<br>
<hr color="#00FF00">
<!----------------------------------------------------------------------------->
<h2> Key IDs and Fingerprints </h2>

OpenPGP generates Key IDs and fingerprints.
The goal of this section is to define what they are and how OpenPGP computes them.
<p>

RFC-4880 section 12.2 defines OpenPGP fingerprints.
There are two types: a V3 MD5 fingerprint and a V4 SHA-1 fingerprint.
<blockquote><i>
   The fingerprint of a V3 key is formed by hashing the body (but not
   the two-octet length) of the MPIs that form the key material (public
   modulus n, followed by exponent e) with MD5.
<p>
   A V4 fingerprint is the 160-bit SHA-1 hash of the octet 0x99,
   followed by the two-octet packet length, followed by the entire
   Public-Key packet starting with the version field.
</i></blockquote>

But what are the keys that are fingerprinted?
Perhaps we can learn something by studying the format of a gpg export file.
We have gpg export files for Zeke and Zeta.
<p>

When we do a pgpdump of zeta-export.pgp we see five packets.
It appears that there are two public keys being exported here.
One is in the first three packets: public key packet, user ID packet, signature packet.
The other is in the last two packets: public subkey packet, signature signature.
Here's an abbreviated version of the output:
<pre>
Old: Public Key Packet(tag 6)(141 bytes)
	RSA n(1024 bits) - ...
	RSA e(17 bits) - ...
Old: User ID Packet(tag 13)(42 bytes)
	User ID - zeta (Blacklight ghost) <zeta@example.org>
Old: Signature Packet(tag 2)(182 bytes)
	Sig type - Positive certification of a User ID and Public Key packet(0x13).
	Sub: issuer key ID(sub 16)(8 bytes)
		Key ID - 0x22110B2FA30950F5
Old: Public Subkey Packet(tag 14)(141 bytes)
	RSA n(1024 bits) - ...
	RSA e(17 bits) - ...
Old: Signature Packet(tag 2)(317 bytes)
	Sig type - Subkey Binding Signature(0x18).
	Sub: issuer key ID(sub 16)(8 bytes)
		Key ID - 0x22110B2FA30950F5
	Sub: issuer key ID(sub 16)(8 bytes)
		Key ID - 0x0AD8B7F81C568FA4
</pre>



So what are these two public keys?
Are they Zeta's public verification key (pub) and public encryption key (sub)?
What are the actual values of the modulii and the exponents?
Which key is used to create the signature?
<p>

Look at the two Key ID values in the subpackets of each Signature Packet above.
They are each 64 bits (8 bytes).
<ul>
<li>  Key ID: <tt>0xDD837FB872A7727B</tt>.
<li>  Key ID: <tt>0x483942CCCC389E9F</tt>.
</ul>

RFC-4880 section 12.2 also defines OpenPGP Key IDs.
There are two types: a V3 Key ID and a V4 Key ID.
<blockquote><i>
  For a V3 key, the eight-octet Key ID consists of the low 64 bits of
  the public modulus of the RSA key.
<p>
  [For a V4 key:] The Key ID is the low-order 64 bits of the [V4] fingerprint.
</i></blockquote>

RFC-4880 section 5.2.3 specifies the format for Version 4 signature packets
which is what we have above. These use subpackets.
In particular, we're interested in subpacket 16, which specifies the Issuer.
Section 5.2.3.5 specifies this field as 8 bytes and describes it as
"The OpenPGP Key ID of the key issuing the signature."
The gerund "issuing" is ambiguous. 
Is the issuing key a private signature key that signs the public key?
Or is the issuing key the public key that is being signed?
<p>

We can list Zeta's public and private keys with gpg.
The makefile has the command "zeta-list" that does this for us.
When we do a "make zeta-list" we can see the lower 32-bits of the Key IDs above.
Here's an abbreviated version of the output.
<pre>
  zeta-public.pgp
  -----------------
  pub   1024R/72A7727B 2011-02-08
  sub   1024R/CC389E9F 2011-02-08
  
  zeta-secret.pgp
  -----------------
  sec   1024R/72A7727B 2011-02-08
  ssb   1024R/CC389E9F 2011-02-08
</pre>

Note that Zeta has two public keys (pub, sub) and two secret keys (sec, ssb).
In the 2011feb08 journal entry we hypothesized definitions for these four.
Here they are again with some expansion.
<ul>
<li>  <tt>pub</tt> is Zeta's public verification key (ns xv)<br>
      with signature modulus ns and verification exponent xv.
<p>
<li>  "sub" is Zeta's public encryption key (ne xe)<br>
      with encryption modulus ne and encryption exponent xe.
<p>
<li>  "sec" is Zeta's private signature key (ns xs)<br>
      with signature modulus ns and signature exponent xs.
<p>
<li>  "ssb" is Zeta's private decryption key (ne nd)<br>
      with encryption modulus ne and decryption exponent xd.
</ul>


<br>
<hr color="#00FF00">
<!----------------------------------------------------------------------------->
<h2> Signature subpacket types </h2>

RFC-4880 section 5.2.3 defines OpenPGP signature subpackets.
"A number of subpackets are currently defined.
Some subpackets apply to the signature itself and some are attributes of the key."

<pre>
 subpacket-02  Signature Creation Time
 subpacket-03  Signature Expiration Time
 subpacket-04  Exportable Certification
 subpacket-05  Trust Signature
 subpacket-06  Regular Expression
 subpacket-07  Revocable
 subpacket-09  Key Expiration Time
 subpacket-11  Preferred Symmetric Algorithms
 subpacket-12  Revocation Key
 subpacket-16  Issuer
 subpacket-20  Notation Data
 subpacket-21  Preferred Hash Algorithms
 subpacket-22  Preferred Compression Algorithms
 subpacket-23  Key Server Preferences
 subpacket-24  Preferred Key Server
 subpacket-25  Primary User ID
 subpacket-26  Policy URI
 subpacket-27  Key Flags
 subpacket-28  Signer's User ID
 subpacket-29  Reason for Revocation
 subpacket-30  Features
 subpacket-31  Signature Target
 subpacket-32  Embedded Signature
</pre>

<br>
<hr color="#00FF00">
<!----------------------------------------------------------------------------->
<h2> subpacket-02 </h2>

The subpacket-02 is the <i>Signature Creation Time</i> subpacket.<br>
[See RFC-4880 section 5.2.3.4].
<p>

The subpacket-02 specifies the time that a signature was created.
It must be present in the hashed area of the Signature packet.
<p>

<h3> Grammar </h3>
<pre>
  subpacket-02 :=
      sub-length
      sub-type
      epoch-secs
</pre>
<p>

<code>epoch-secs</code> is a four byte field.
It represents a 32-bit integer that specifies the Epoch 1970 seconds
at the time the signature was created.
<p>

<h3> Example </h3>
<pre>
  sub-length    05
  sub-type      02
  epoch-secs    4C BE 3C AD
</pre>
<p>

The example shows a subpacket-02 which contains a signature creation time.
The sub-length field (05) specifies a subpacket body length of five bytes.
The sub-type field (02) specifies a Signature Creation Time subpacket.
The epoch-secs field (4C BE 3C AD) specifies the date and time that the 
signature was created.
<p>

<br>
<hr color="#00FF00">
<!----------------------------------------------------------------------------->
<h2> subpacket-03 </h2>

The subpacket-03 is the <i>Signature Expiration Time</i> subpacket.<br>
[See RFC-4880 section 5.2.3.10].
<p>

The subpacket-03 specifies the time that a signature will expire.
If this subpacket is not present or has a value of zero, 
the signature never expires.
<p>

<h3> Grammar </h3>
<pre>
  subpacket-03 :=
      sub-length
      sub-type
      sig-period
</pre>
<p>

<code>sig-period</code> is a four byte field.
It represents a 32-bit integer that specifies the validity period of the signature,
the number of seconds after the signature creation time.
<p>

<h3> Example </h3>
<pre>
  sub-length    05
  sub-type      03
  sig-period    00 10 00 00
</pre>
<p>

<br>
<hr color="#00FF00">
<!----------------------------------------------------------------------------->
<h2> subpacket-04 </h2>
The subpacket-04 is the <i>Exportable Certification</i> subpacket.<br>
[See RFC-4880 section 5.2.3.11].
<p>

The subpacket-04 specifies whether or not a certification signature 
is <i>exportable</i>, that is, meant to be used by users other than the issuer.
If the subpacket-04 is not present, the certification is exportable.
<p>

<h3> Grammar </h3>
<pre>
  subpacket-04 :=
      sub-length
      sub-type
      export-flag
</pre>
<p>

<code>export-flag</code> is a boolean value.
It either has a value of 0x01 if the signature is exportable,
or a value of 0x00 if the signature is local.
<p>

<h3> Example </h3>
<pre>
  sub-length    02
  sub-type      04
  sig-period    01
</pre>
<p>

<br>
<hr color="#00FF00">
<!----------------------------------------------------------------------------->
<h2> subpacket-05 </h2>
The subpacket-05 is the <i>Trust Signature</i> subpacket.<br>
[See RFC-4880 section 5.2.3.13].
<p>

The subpacket-05 specifies both a level and an amount of trust for a signature.
<p>

<h3> Grammar </h3>
<pre>
  subpacket-05 :=
      sub-length
      sub-type
      trust-level
      trust-amount
</pre>
<p>

<code>trust-level</code> is a positive integer in the range [0,255].
Level 0 has the same meaning as an ordinary validity signature.
Level 1 means that the signed key is asserted to be a valid trusted introducer, 
with the 2nd octet of the body specifying the degree of trust.
Level 2 means that the signed key is asserted to be trusted to issue 
level 1 trust signatures, i.e., that it is a <i>meta introducer</i>.
<p>

<code>trust-amount</code> is a positive integer in the range [0,255].
Values less than 120 indicate partial trust and 
values of 120 or greater indicate complete trust.
Implementations should emit values of 60 (0x3C) for partial trust and 
120 (0x78) for complete trust.
<p>

<h3> Example </h3>
<pre>
  sub-length    03
  sub-type      05
  trust-level   02
  trust-amount  78
</pre>
<p>


<br>
<hr color="#00FF00">
<!----------------------------------------------------------------------------->
<h2> subpacket-06 </h2>
The subpacket-06 is the <i>Regular Expression</i> subpacket.<br>
[See RFC-4880 section 5.2.3.14].
<p>

   (null-terminated regular expression)
<p>
   Used in conjunction with trust Signature packets (of level > 0) to
   limit the scope of trust that is extended.  Only signatures by the
   target key on User IDs that match the regular expression in the body
   of this packet have trust extended by the trust Signature subpacket.
   The regular expression uses the same syntax as the Henry Spencer's
   "almost public domain" regular expression [REGEX] package.  A
   description of the syntax is found in Section 8 below.

<br>
<hr color="#00FF00">
<!----------------------------------------------------------------------------->
<h2> subpacket-07 </h2>
The subpacket-07 is the <i>Revocable</i> subpacket.<br>
[See RFC-4880 section 5.2.3.12].
<p>

   (1 octet of revocability, 0 for not, 1 for revocable)
<p>
   Signature's revocability status.  The packet body contains a Boolean
   flag indicating whether the signature is revocable.  Signatures that
   are not revocable have any later revocation signatures ignored.  They
   represent a commitment by the signer that he cannot revoke his
   signature for the life of his key.  If this packet is not present,
   the signature is revocable.


<br>
<hr color="#00FF00">
<!----------------------------------------------------------------------------->
<h2> subpacket-09 </h2>
The subpacket-09 is the <i>Key Expiration Time</i> subpacket.<br>
[See RFC-4880 section 5.2.3.6].
<p>

   (4-octet time field)
<p>
   The validity period of the key.  This is the number of seconds after
   the key creation time that the key expires.  If this is not present
   or has a value of zero, the key never expires.  This is found only on
   a self-signature.


<br>
<hr color="#00FF00">
<!----------------------------------------------------------------------------->
<h2> subpacket-11 </h2>
The subpacket-11 is the <i>Preferred Symmetric Algorithms</i> subpacket.<br>
[See RFC-4880 section 5.2.3.7].
<p>

   (array of one-octet values)
<p>
   Symmetric algorithm numbers that indicate which algorithms the key
   holder prefers to use.  The subpacket body is an ordered list of
   octets with the most preferred listed first.  It is assumed that only
   algorithms listed are supported by the recipient's software.
   Algorithm numbers are in Section 9.  This is only found on a self-
   signature.


<br>
<hr color="#00FF00">
<!----------------------------------------------------------------------------->
<h2> subpacket-12 </h2>
The subpacket-12 is the <i>Revocation Key</i> subpacket.<br>
[See RFC-4880 section 5.2.3.15].
<p>

   (1 octet of class, 1 octet of public-key algorithm ID, 20 octets of
   fingerprint)
<p>
   Authorizes the specified key to issue revocation signatures for this
   key.  Class octet must have bit 0x80 set.  If the bit 0x40 is set,
   then this means that the revocation information is sensitive.  Other
   bits are for future expansion to other kinds of authorizations.  This
   is found on a self-signature.
<p>
   If the "sensitive" flag is set, the keyholder feels this subpacket
   contains private trust information that describes a real-world
   sensitive relationship.  If this flag is set, implementations SHOULD
   NOT export this signature to other users except in cases where the
   data needs to be available: when the signature is being sent to the
   designated revoker, or when it is accompanied by a revocation
   signature from that revoker.  Note that it may be appropriate to
   isolate this subpacket within a separate signature so that it is not
   combined with other subpackets that need to be exported.

<br>
<hr color="#00FF00">
<!----------------------------------------------------------------------------->
<h2> subpacket-16 </h2>
The subpacket-16 is the <i>Issuer</i> subpacket.<br>
[See RFC-4880 section 5.2.3.5].
<p>

   (8-octet Key ID)
<p>
   The OpenPGP Key ID of the key issuing the signature.


<br>
<hr color="#00FF00">
<!----------------------------------------------------------------------------->
<h2> subpacket-20 </h2>
The subpacket-20 is the <i>Notation Data</i> subpacket.<br>
[See RFC-4880 section 5.2.3.16].
<p>

       (4 octets of flags, 2 octets of name length (M),
                           2 octets of value length (N),
                           M octets of name data,
                           N octets of value data)
<p>
   This subpacket describes a "notation" on the signature that the
   issuer wishes to make.  The notation has a name and a value, each of
   which are strings of octets.  There may be more than one notation in
   a signature.  Notations can be used for any extension the issuer of
   the signature cares to make.  The "flags" field holds four octets of
   flags.
<p>
   All undefined flags MUST be zero.  Defined flags are as follows:
<ul>
<li>       First octet: 0x80 = human-readable.  This note value is text.
<p>
<li>       Other octets: none.
</ul>
   Notation names are arbitrary strings encoded in UTF-8.  They reside
   in two namespaces: The IETF namespace and the user namespace.
<p>
   The IETF namespace is registered with IANA.  These names MUST NOT
   contain the "@" character (0x40).  This is a tag for the user
   namespace.
<p>
   Names in the user namespace consist of a UTF-8 string tag followed by
   "@" followed by a DNS domain name.  Note that the tag MUST NOT
   contain an "@" character.  For example, the "sample" tag used by
   Example Corporation could be "sample@example.com".
<p>
   Names in a user space are owned and controlled by the owners of that
   domain.  Obviously, it's bad form to create a new name in a DNS space
   that you don't own.
<p>
   Since the user namespace is in the form of an email address,
   implementers MAY wish to arrange for that address to reach a person
   who can be consulted about the use of the named tag.  Note that due
   to UTF-8 encoding, not all valid user space name tags are valid email
   addresses.
<p>
   If there is a critical notation, the criticality applies to that
   specific notation and not to notations in general.

<br>
<hr color="#00FF00">
<!----------------------------------------------------------------------------->
<h2> subpacket-21 </h2>
The subpacket-21 is the <i>Preferred Hash Algorithms</i> subpacket.<br>
[See RFC-4880 section 5.2.3.8].
<p>

   (array of one-octet values)
<p>
   Message digest algorithm numbers that indicate which algorithms the
   key holder prefers to receive.  Like the preferred symmetric
   algorithms, the list is ordered.  Algorithm numbers are in Section 9.
   This is only found on a self-signature.


<br>
<hr color="#00FF00">
<!----------------------------------------------------------------------------->
<h2> 0xsubpacket-22 </h2>
The 0xsubpacket-22 is the <i>Preferred Compression Algorithms</i> subpacket.<br>
[See RFC-4880 section 5.2.3.9].
<p>

<h4> 5.2.3.9.  Preferred Compression Algorithms </h4>

   (array of one-octet values)
<p>
   Compression algorithm numbers that indicate which algorithms the key
   holder prefers to use.  Like the preferred symmetric algorithms, the
   list is ordered.  Algorithm numbers are in Section 9.  If this
   subpacket is not included, ZIP is preferred.  A zero denotes that
   uncompressed data is preferred; the key holder's software might have
   no compression software in that implementation.  This is only found
   on a self-signature.



<br>
<hr color="#00FF00">
<!----------------------------------------------------------------------------->
<h2> subpacket-23 </h2>
The subpacket-23 is the <i>Key Server Preferences</i> subpacket.<br>
[See RFC-4880 section 5.2.3.17].
<p>

   (N octets of flags)
<p>
   This is a list of one-bit flags that indicate preferences that the
   key holder has about how the key is handled on a key server.  All
   undefined flags MUST be zero.
<p>
   First octet: 0x80 = No-modify <br>
       the key holder requests that this key only be modified or updated
       by the key holder or an administrator of the key server.
<p>
   This is found only on a self-signature.


<br>
<hr color="#00FF00">
<!----------------------------------------------------------------------------->
<h2> subpacket-24 </h2>
The subpacket-24 is the <i>Preferred Key Server</i> subpacket.<br>
[See RFC-4880 section 5.2.3.18].
<p>

   (String)
<p>
   This is a URI of a key server that the key holder prefers be used for
   updates.  Note that keys with multiple User IDs can have a preferred
   key server for each User ID.  Note also that since this is a URI, the
   key server can actually be a copy of the key retrieved by ftp, http,
   finger, etc.


<br>
<hr color="#00FF00">
<!----------------------------------------------------------------------------->
<h2> subpacket-25 </h2>
The subpacket-25 is the <i>Primary User ID</i> subpacket.<br>
[See RFC-4880 section 5.2.3.19].
<p>

   (1 octet, Boolean)
<p>
   This is a flag in a User ID's self-signature that states whether this
   User ID is the main User ID for this key.  It is reasonable for an
   implementation to resolve ambiguities in preferences, etc. by
   referring to the primary User ID.  If this flag is absent, its value
   is zero.  If more than one User ID in a key is marked as primary, the
   implementation may resolve the ambiguity in any way it sees fit, but
   it is RECOMMENDED that priority be given to the User ID with the most
   recent self-signature.
<p>
   When appearing on a self-signature on a User ID packet, this
   subpacket applies only to User ID packets.  When appearing on a
   self-signature on a User Attribute packet, this subpacket applies
   only to User Attribute packets.  That is to say, there are two
   different and independent "primaries" -- one for User IDs, and one
   for User Attributes.



<br>
<hr color="#00FF00">
<!----------------------------------------------------------------------------->
<h2> subpacket-26 </h2>
The subpacket-26 is the <i>Policy URI</i> subpacket.<br>
[See RFC-4880 section 5.2.3.20].
<p>

   (String)
<p>
   This subpacket contains a URI of a document that describes the policy
   under which the signature was issued.


<br>
<hr color="#00FF00">
<!----------------------------------------------------------------------------->
<h2> subpacket-27 </h2>
The subpacket-27 is the <i>Key Flags</i> subpacket.<br>
[See RFC-4880 section 5.2.3.21].
<p>

   (N octets of flags)
<p>
   This subpacket contains a list of binary flags that hold information
   about a key.  It is a string of octets, and an implementation MUST
   NOT assume a fixed size.  This is so it can grow over time.  If a
   list is shorter than an implementation expects, the unstated flags
   are considered to be zero.  The defined flags are as follows:
<p>
       First octet:
<ul>
<li>   0x01 - This key may be used to certify other keys.
<p>
<li>   0x02 - This key may be used to sign data.
<p>
<li>   0x04 - This key may be used to encrypt communications.
<p>
<li>   0x08 - This key may be used to encrypt storage.
<p>
<li>   0x10 - The private component of this key may have been split
              by a secret-sharing mechanism.
<p>
<li>   0x20 - This key may be used for authentication.
<p>
<li>   0x80 - The private component of this key may be in the
              possession of more than one person.
</ul>

   Usage notes:
<p>
   The flags in this packet may appear in self-signatures or in
   certification signatures.  They mean different things depending on
   who is making the statement -- for example, a certification signature
   that has the "sign data" flag is stating that the certification is
   for that use.  On the other hand, the "communications encryption"
   flag in a self-signature is stating a preference that a given key be
   used for communications.  Note however, that it is a thorny issue to
   determine what is "communications" and what is "storage".  This
   decision is left wholly up to the implementation; the authors of this
   document do not claim any special wisdom on the issue and realize
   that accepted opinion may change.
<p>
   The "split key" (0x10) and "group key" (0x80) flags are placed on a
   self-signature only; they are meaningless on a certification
   signature.  They SHOULD be placed only on a direct-key signature
   (type 0x1F) or a subkey signature (type 0x18), one that refers to the
   key the flag applies to.

<br>
<hr color="#00FF00">
<!----------------------------------------------------------------------------->
<h2> subpacket-28 </h2>
The subpacket-28 is the <i>Signer's User ID</i> subpacket.<br>
[See RFC-4880 section 5.2.3.22].
<p>

   (String)
<p>
   This subpacket allows a keyholder to state which User ID is
   responsible for the signing.  Many keyholders use a single key for
   different purposes, such as business communications as well as
   personal communications.  This subpacket allows such a keyholder to
   state which of their roles is making a signature.
<p>
   This subpacket is not appropriate to use to refer to a User Attribute
   packet.

<br>
<hr color="#00FF00">
<!----------------------------------------------------------------------------->
<h2> subpacket-29 </h2>
The subpacket-29 is the <i>Reason for Revocation</i> subpacket.<br>
[See RFC-4880 section 5.2.3.23].
<p>

<h4> 5.2.3.23.  Reason for Revocation </h4>

   (1 octet of revocation code, N octets of reason string)
<p>
   This subpacket is used only in key revocation and certification
   revocation signatures.  It describes the reason why the key or
   certificate was revoked.
<p>
   The first octet contains a machine-readable code that denotes the
   reason for the revocation:
<ul>
<li>    0  - No reason specified (key revocations or cert revocations)
<p>
<li>    1  - Key is superseded (key revocations)
<p>
<li>    2  - Key material has been compromised (key revocations)
<p>
<li>    3  - Key is retired and no longer used (key revocations)
<p>
<li>    32 - User ID information is no longer valid (cert revocations)
<p>
<li>    100-110 - Private Use
</ul>
   Following the revocation code is a string of octets that gives
   information about the Reason for Revocation in human-readable form
   (UTF-8).  The string may be null, that is, of zero length.  The
   length of the subpacket is the length of the reason string plus one.
   An implementation SHOULD implement this subpacket, include it in all
   revocation signatures, and interpret revocations appropriately.
   There are important semantic differences between the reasons, and
   there are thus important reasons for revoking signatures.
<p>
   If a key has been revoked because of a compromise, all signatures
   created by that key are suspect.  However, if it was merely
   superseded or retired, old signatures are still valid.  If the
   revoked signature is the self-signature for certifying a User ID, a
   revocation denotes that that user name is no longer in use.  Such a
   revocation SHOULD include a 0x20 code.
<p>
   Note that any signature may be revoked, including a certification on
   some other person's key.  There are many good reasons for revoking a
   certification signature, such as the case where the keyholder leaves
   the employ of a business with an email address.  A revoked
   certification is no longer a part of validity calculations.

<br>
<hr color="#00FF00">
<!----------------------------------------------------------------------------->
<h2> subpacket-30 </h2>
The subpacket-30 is the <i>Features</i> subpacket.<br>
[See RFC-4880 section 5.2.3.24].
<p>

<h4> 5.2.3.24.  Features </h4>

   (N octets of flags)
<p>
   The Features subpacket denotes which advanced OpenPGP features a
   user's implementation supports.  This is so that as features are
   added to OpenPGP that cannot be backwards-compatible, a user can
   state that they can use that feature.  The flags are single bits that
   indicate that a given feature is supported.
<p>
   This subpacket is similar to a preferences subpacket, and only
   appears in a self-signature.
<p>
   An implementation SHOULD NOT use a feature listed when sending to a
   user who does not state that they can use it.
<p>
   Defined features are as follows:
<p>
       First octet:
<p>
       0x01 - Modification Detection (packets 18 and 19)
<p>
   If an implementation implements any of the defined features, it
   SHOULD implement the Features subpacket, too.
<p>
   An implementation may freely infer features from other suitable
   implementation-dependent mechanisms.

<br>
<hr color="#00FF00">
<!----------------------------------------------------------------------------->
<h2> subpacket-31 </h2>
The subpacket-31 is the <i>Signature Target</i> subpacket.<br>
[See RFC-4880 section 5.2.3.25].
<p>

<h4> 5.2.3.25.  Signature Target </h4>

   (1 octet public-key algorithm, 1 octet hash algorithm, N octets hash)
<p>
   This subpacket identifies a specific target signature to which a
   signature refers.  For revocation signatures, this subpacket
   provides explicit designation of which signature is being revoked.
   For a third-party or timestamp signature, this designates what
   signature is signed.  All arguments are an identifier of that target
   signature.
<p>
   The N octets of hash data MUST be the size of the hash of the
   signature.  For example, a target signature with a SHA-1 hash MUST
   have 20 octets of hash data.


<br>
<hr color="#00FF00">
<!----------------------------------------------------------------------------->
<h2> subpacket-32 </h2>
The subpacket-32 is the <i>Embedded Signature</i> subpacket.<br>
[See RFC-4880 section 5.2.3.26].
<p>

<h4> 5.2.3.26.  Embedded Signature </h4>

   (1 signature packet body)
<p>
   This subpacket contains a complete Signature packet body as
   specified in Section 5.2 above.  It is useful when one signature
   needs to refer to, or be incorporated in, another signature.


<br>
<hr color="#00FF00">
<!----------------------------------------------------------------------------->


<br>
</body>
</html>
